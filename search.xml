<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python - Coding Style]]></title>
    <url>%2Fposts%2F515db561%2F</url>
    <content type="text"><![CDATA[Coding styleWhitespace 对齐使用4个空格，而不用 tab 制表符 每行最多79个字符 长条件表达式分多行时，需要在原来缩进的基础上增加一层缩进，参考例1 在一文件里，function 和 class 之间空两行隔开 在 class 里，成员方法间空一行隔开 不能使用隐式分行的，需要使用反斜杠连接符，分行同样遵循条件表示式的分行缩进风格，参考例2 对于赋值操作，操作符前后仅有一个空格，参考例3 函数调用、列表索引以及关键字参数与括号不带空格 For example 1: if (expression_1, expression_2, expression_3, expression_4): do_something() For example 2: with open('/path/to/some/file/you/want/to/read') as file_1, \ open('/path/to/some/file/being/written', 'w') as files_2: file_2.write(file_1.read()) For example 3: Yes: x = 1 y = 2 long_variable = 3 No: x = 1 y = 2 long_variable = 3 For example 4: Immediately before the open parenthesis that starts the argument list of a function call: Yes: spam(1) No: spam (1) Immediately before the open parenthesis that starts an indexing or slicing: Yes: dct['key'] = lst[index] No: dct ['key'] = lst [index] if (expression): do_something() Yes: ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] ham[lower:upper], ham[lower:upper:], ham[lower::step] ham[lower+offset : upper+offset] ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)] ham[lower + offset : upper + offset] No: ham[lower + offset:upper + offset] ham[1: 9], ham[1 :9], ham[1:9 :3] ham[lower : : upper] ham[ : upper] Naming 函数、变量和属性使用小写字母加下划线的命名风格，参考例5 protected 实例属性使用单下划线开头，参考例6 private 实例属性使用双下划线开头，参考例6 类和异常使用单词首字母大写的命名风格，参考例6 常量使用全部字母大写的风格 类的成员方法第一个参数是self For example 5: Format: lowercase_underscore def print_usage(): print("Usage: xxx") For example 6: class TestEmployee: _emp_count = 0 __salary = 10000 表达式和语句 检查长度，而不检查空值，因为使用 if not somelist 当 somelist 是空值时，返回值是 false，参考例7 避免单行 if for while 和 except，参考例8 import通常分行,并且位于文件的顶部，分成三组（标准库、相关的第三方库、本地库）排放，每组间空一行隔开，参考例9 For example 7: Yes: if len(somelist) == 0: do_something() No: if somelist == []: do_something() if not somelist: do_something() For example 8: Yes: if expression: do_something() No: if expression: do_something() For example 9: import os import sys from subprocess import Popen, PIPE]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - Setup WPA2-Enterprise AP]]></title>
    <url>%2Fposts%2Fb0b35cda%2F</url>
    <content type="text"><![CDATA[How to setup a FreeRadius Server on OpenWrtInstall Packages# opkg update # opkg install freeradius2 freeradius2-mod-always freeradius2-mod-attr-filter freeradius2-mod-attr-rewrite freeradius2-mod-chap freeradius2-mod-detail freeradius2-mod-eap freeradius2-mod-eap-gtc freeradius2-mod-eap-md5 freeradius2-mod-eap-mschapv2 freeradius2-mod-eap-peap freeradius2-mod-eap-tls freeradius2-mod-eap-ttls freeradius2-mod-exec freeradius2-mod-expiration freeradius2-mod-expr freeradius2-mod-files freeradius2-mod-ldap freeradius2-mod-logintime freeradius2-mod-mschap freeradius2-mod-pap # opkg install freeradius2-mod-passwd freeradius2-mod-preprocess freeradius2-mod-radutmp freeradius2-mod-realm freeradius2-mod-sql freeradius2-mod-sql-mysql freeradius2-mod-sql-pgsql freeradius2-mod-sql-sqlite freeradius2-mod-sqlcounter freeradius2-mod-sqllog freeradius2-utils freeradius2-democerts Note that if there are any errors like this:Collected errors:* opkg_install_cmd: Cannot install package freeradius2-democerts . We should try again. Issue opkg install freeradius2-democerts command. Change Configuration FileAdd a New UserModify /etc/freeradius2/users, append one line might be: kyson Cleartext-Password := &quot;helloworld1&quot; Note that “kyson” is username, and “helloworld1” is password for wireless client. Define RADIUS ClientModify /etc/freeradius2/clients.conf, change those items on the section: client localhost { ipaddr = 192.168.8.1 secret = helloworld } RADIUS Server Configuration FileModify /etc/freeradius2/radiusd.conf, change those items on flowing sections: listen { type = auth # interface = br-lan } log { auth = yes } Generate New Certificates and Key With Openssl# opkg install openssl-util # cd /etc/freeradius2/certs &amp;&amp; rm *.pem # openssl genrsa -des3 –out ca.key 2048 # openssl req -new –x509 –days 9999 –key ca.key –out ca.pem # openssl genrsa –des3 –out server.key 2048 # openssl req –new –key server.key –out key.csr # openssl x509 –req –days 9999 –in server.csr –CA ca.pem –Cakey ca.key –set_serial 01 –out server.pem Configuration EAPModify /etc/freeradius2/eap.conf, change those items on the section: eap { tls { # This password is CA key password private_key_password = goodlife private_key_file = ${certdir}/server.key } } Change Wireless Configuration File to Support WPA2Modify /etc/config/wireless, one example might be: config wifi-iface option device &apos;radio0&apos; option network &apos;lan&apos; option mode &apos;ap&apos; option ssid &apos;GL-AR150-0fd&apos; option wds &apos;1&apos; option ifname &apos;wlan0&apos; option encryption &apos;wpa2&apos; # This password is consistent with /etc/freeradius2/clients.conf option auth_secret &apos;helloworld&apos; option auth_server &apos;192.168.8.1&apos; option auth_port &apos;1812&apos; Note that we should reboot the device when finishing the above step. As you see, successful in setting up WPA2-Enterprise security for router. Connect to WPA2-Enterprise APOn Windows7, my settings are as follows: Connecting to the AP which ssid is GL-AR150-0fd, and typing username and password. It works well. Seeing the radius log on router. # cat /var/log/radius.log Mon Sep 25 15:34:35 2017 : Info: Loaded virtual server Mon Sep 25 15:34:35 2017 : Info: Ready to process requests.Mon Sep 25 15:39:29 2017 : Auth: Login OK: [kyson] (from client localhost port 1 cli F0-D5-BF-7F-F6-4D via TLS tunnel)Mon Sep 25 15:39:29 2017 : Auth: Login OK: [kyson] (from client localhost port 1 cli F0-D5-BF-7F-F6-4D)]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Syncing Fork Repo]]></title>
    <url>%2Fposts%2F5255e100%2F</url>
    <content type="text"><![CDATA[How To Sync Fork RepoOverview在使用 github 过程，遇到过这么一个问题：当我 Fork 一个工程到自己的 Repo 进行开发，随着 original repository 不断的更新，我想把更新的内容同步到我的 Repo 怎么办？git fetch + git merge 能解决这个问题。 Checkout Fork Repo克隆我们 fork 过来的 repository 到本地主机： $ git clone https://github.com/YOUR_USERNAME/YOUR_FORK.git Configuring A Remote查看当前的 repository 的远程源： $ git remote -v 添加一个我们要同步的 repository，通常是 fork 过来的 repository 的出处： $ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 检查我们新添加的 remote repository： $ git remote -v origin https://github.com/domino-team/lede-1701.git (fetch) origin https://github.com/domino-team/lede-1701.git (push) upstream https://github.com/lede-project/source.git (fetch) upstream https://github.com/lede-project/source.git (push) Syncing A Fork拉取上游源的分支以及相应的 commits 到本地，这里我需要拉取 LEDE 的 lede-1701 分支的 commits： $ git fetch upstream 合并到 fork repository，以合并 LEDE 源的 lede-1701 分支为例： $ git merge upstream/lede-1701 注意：如果合并过程出现冲突，我们需要手动地解决合并冲突问题。 Generate a list of the files affected by the merge conflict. In this example, the file styleguide.md has a merge conflict. $ git status # On branch branch-b # You have unmerged paths. # (fix conflicts and run &quot;git commit&quot;) # # Unmerged paths: # (use &quot;git add ...&quot; to mark resolution) # # both modified: styleguide.md # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 在冲突文件我们可以找到诸如下面格式的内容： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD open an issue ======= ask your question in IRC. &gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 表示当前分支，&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a 表示要合并的分支，======= 表示分界线，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 和 ======= 之间的内容表示当前分支的内容，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a 之间的内容为要合并分支的内容。决定保留哪个分支的内容，删除另一分支的内容，并且删除冲突标识符 “&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD”、”=======” 和 “&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a”。 完成同步以后，我们就可以把这些新内容 push 到 fork repository，这样就能实现 fork 过来的 repository 能跟 original repository 保持一致。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Language - Foundation]]></title>
    <url>%2Fposts%2F6fc7a62f%2F</url>
    <content type="text"><![CDATA[Basic Syntax分号C 程序中，分号表示语句的终止符。下面表示两条语句： printf("Hello World! \n"); return 0; 注释注释是 C 代码的帮助文本，被注释的代码不会被编译器编译。C 语言支持两种注释表示，分别是单行注释和多行注释。单行注释：以 “//“ 开头，到行尾的内容被注释；多行注释：以 “/*“ 开头，并以 “*/“ 结尾，中间的内容被注释。如： // This is single line comment /** * This is multiple lines comment */ 标识符标识符是指我们为变量variable、宏macro，函数function 等取的名字，它由字母（A-Z,a-z）、数字（0-9）、下划线”_”组成，并且首字符不能是数字，但可以是字母或者下划线。有效的标识符： abc _tmp a_123 关键字C 语言的保留字不能用作常亮、变量或任何标识符名称，关键字列表： auto else long switch break enum register typedef case extern return union char float short unsigned const for signed void continue goto sizeof volatile default if static while do int struct _Packed double Whitespace只有空格字符的行称为空行，C 编译器会忽略空行。C 程序中空格字符是描述空格(‘ ‘)、定位字符(‘ \t ‘)、CR(‘ \r ‘)、换行(‘ \n ‘)、垂直定位字符(‘ \v ‘)或翻页(‘ \f ‘)的术语。空格字符可以划分语句，如声明一整形变量： int age; 这里，int 与 age 之间必须有空格，编译器才能区分它们。另外，空格可以用于代码缩进以提高代码的可阅读性： fruit = apples + oranges; Data TypesInteger TypesFloating-Point TypesVoid TypeVariablesConstantsOperatorsDecision MakingLoopsFunctionArrayPointers未完，待续！！]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac80211 - Home]]></title>
    <url>%2Fposts%2F2047704a%2F</url>
    <content type="text"><![CDATA[OverviewTo be able to control wireless drivers from userspace, some IPC communication processes between kernel and userspace are used. At first ioctl with vendor dependent APIs was used. In 1996, Jean Tourrilhes creates wireless extensions (WE or WEXT). The Wireless Extension (WE) is a generic API allowing a driver to expose to the user space configuration and statistics specific to common Wireless LANs. In 2006, John Linville creates mac80211 and Johannes Berg creates cfg80211 and nl80211. Together it is intended to replace wireless extensions. +-------------+ | | | Userspace | | | +-------------+ ^ - - - | - - - - | nl80211 v +-------------+ | | | cfg80211 | | | +-------------+ +-------------+ | | | mac80211 | | driver | | | +-------------+ An important point is that nl80211/cfg80211/mac80211 no longer use ioctl, they use netlink. So, tools like iw, hostapd or the wpa_supplicant use some netlink libraries (like libnl or libnl-tiny) and the netlink interface public header which is of course nl80211.h. There is not so much documentations, but I advice you to read the libnl documentation and then the iw source code (because iw use libnl). Mac80211 Framework nl80211 is the interface between user space software (iw, wpa_supplicant, etc.) and the kernel (cfg80211 and mac80211 kernel modules, and specific drivers). The WiFi drivers and hardware could be Full-MAC or Soft-MAC (see Wireless_network_interface_controller). cfg80211_ops is a set of operations that Full-MAC drivers and mac80211 module register to cfg80211 module. ieee80211_ops is a set of operations that Soft-MAC drivers register to mac80211 module. ReferencesHow nl80211 library &amp; cfg80211 work?]]></content>
      <categories>
        <category>Mac80211</category>
      </categories>
      <tags>
        <tag>mac80211</tag>
        <tag>netlink</tag>
        <tag>nl80211</tag>
        <tag>cfg80211</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Language - Introduction]]></title>
    <url>%2Fposts%2F240e0bdb%2F</url>
    <content type="text"><![CDATA[OverviewC 是通用的高级语言，由 Dennis M. Ritchie 发明。UNIX 操作系统、C 编译器和基本上所有 UNIX 的应用程序都是用 C 语言实现的。C 语言现在已经成为一门被广泛使用的专业语言，其有以下一些特性： Easy to learn（易学） Strutured language（结构化语言） It produces effient programs（效率高） It can handle low-level activities（处理低层） It can be compiled on a variety of computer platforms（容易移植到不同平台） Environment Setup在开始编程之前，我们需要为 C 语言搭建运行环境，至少需要两个工具：(a) 文本编辑器；(b) C 编译器。 Text Editor编辑器用于编写程序，如 Notepad++、VIM、EMACS 或 Epsilon等，选择合适自己的编译器进行编码。用编辑器新建的文件称为源文件，源文件包含代码，C 程序的源码一般以 “.c” 为后缀。 The C CompileC 语言源码对人可读，但是机器只认识 0 和 1 的机器码，所以需要用编译器将源码“翻译”为机器码。经过编译的源码，最终生成可执行文件。最常用的编译器是 GNU C/C++ 编译器，下面介绍在不同操作系统安装 GNU C/C++ 编译器。 Installation on UNIX/Linux如果使用 UNIX 或者 Linux 操作系统，在命令行执行以下命令检查系统是否已经安装 GCC： $ gcc -v 如果安装了 GNU 编译器，则会在屏幕打印版本信息。如果没有安装，我们可以自己安装。详细安装教程访问：Installing GCC Installation on Mac OS如果使用 Mac OS X，可以从 Apple 官网下载 Xcode IDE，它包含了 GNU C/C++ 编译器。详细安装教程访问：Xcode Installation on Windows如果要在 Windows 安装 GNU C/C++ 编译器，我们需要安装 MinGW - MinGW homepage，下载最新版并且安装，成功安装 MinGW 后，运行 MinGW 安装 gcc-core, gcc-g++, binutils, 和 MinGW runtime。一切无误后，添加 MinGW 的 bin 子目录到 PATH 系统环境变量，安装成功后，我们可以在 dos 命令行使用这些工具（gcc, g++, ar, ranlib, …）。 Program StructureBefore we study the basic building blocks of the C programming language, let us look at a bare minimum C program structure so that we can take it as a reference in the upcoming chapters. Hello World Example Preprocessor Commands Functions Variables Statements &amp; Expressions Comments Let us look at a simple code that would print the words “Hello World”： #include &lt;stdio.h&gt; int main() { /* my first program in C */ printf("Hello, World! \n"); return 0; } Let us take a look at the various parts of the above program： The first line of the program #include is a preprocessor command, which tells a C compiler to include stdio.h file before going to actual compilation. The next line int main() is the main function where the program execution begins. The next line /…/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program. The next line printf(…) is another function available in C which causes the message “Hello, World!” to be displayed on the screen. The next line return 0; terminates the main() function and returns the value 0. Compile and Execute C ProgramLet us see how to save the source code in a file, and how to compile and run it. Following are the simple steps： Open a text editor and add the above-mentioned code. Save the file as hello.c Open a command prompt and go to the directory where you have saved the file. Type gcc hello.c and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line and would generate a.out executable file. Now, type a.out to execute your program. You will see the output “Hello World” printed on the screen. $ gcc hello.c $ ./a.out Hello, World!]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt Core - Initd]]></title>
    <url>%2Fposts%2Ff502ce40%2F</url>
    <content type="text"><![CDATA[Overview我们都知道 linux kernel 启动完成以后，会启动 /sbin/initd 作为第一个用户空间的进程。同样地，OpenWrt 也遵循这个规则，不同的是 OpenWrt 的主服务器进程是 procd，而 procd 是系统启动过程由 initd 切换过来的。 Checkout source使用以下命令克隆 procd 源码到本地： # git clone git://git.openwrt.org/project/procd.git Initd processinitd 进程是在内核启动完成后启动的第一个用户空间进程，它的主程序是 init.c，主要做了以下的一些工作： mount filesystem, proc &amp; sysfs &amp; cgroup &amp; tmpfs &amp; devpts create essential temporary directory, /tmp/run &amp; /tmp/lock &amp; /tmp/state set PATH environment, PATH=”/usr/sbin:/sbin:/usr/bin:/bin” set debug level by finding key is “init_debug” from /proc/cmdline register timeout callback, which call watchdog fork one child process to execute “/sbin/kmodloader /etc/modules-boot.d/“, which will load kernel modules, and parent process continue process management: procd and preinit. For procd, fork a child process to run as hotplug daemon with command “/sbin/procd -h /etc/hotplug-preinit.json”, the parent process register plugd_proc to uloop_process. For preinit, fork a child process to execute “/bin/sh /etc/preinit”, and the parent process register preinit_proc to uloop_process run loop 注意：这里的第7点，用到了 uloop 的进程管理。对于调用者，只需要关心 struct uloop_process 的 pid 和 cb 成员，其中，cb 是回调，当子进程退出时，父进程会收到 SIGCHLD 信号而调用。通过 uloop_process_add 把 struct uloop_process 添加到 uloop 事件循环中。 Initd to Procd我们透过简化代码分析 initd 进程是如何切换到 procd 进程： /* global various */ static struct uloop_process preinit_proc; void preinit(void) { char *init[] = { "/bin/sh", "/etc/preinit", NULL }; preinit_proc.cb = spawn_procd; preinit_proc.pid = fork(); if (!preinit_proc.pid) { execvp(init[0], init); ERROR("Failed to start preinit\n"); exit(-1); } if (preinit_proc.pid &lt;= 0) { ERROR("Failed to start new preinit instance\n"); return; } uloop_process_add(&amp;preinit_proc); } 根据上面提到 uloop 的进程管理可知，一旦执行完 /bin/sh /etc/preinit，则会执行 spawn_procd 回调。spawn_procd 的代码段： static void spawn_procd(struct uloop_process *proc, int ret) { char *argv[] = { "/sbin/procd", NULL}; struct stat s; if (plugd_proc.pid &gt; 0) kill(plugd_proc.pid, SIGKILL); if (!stat("/tmp/sysupgrade", &amp;s)) while (true) sleep(1); execvp(argv[0], argv); } spawn_procd 作为 initd 进程中 uloop_run 的回调函数，其 pid = 1(initd)，通过执行 execvp 拉起一进程取代原进程，这里是 initd 进程被 /sbin/procd 进程取代。至此，procd 成为 OpenWrt 系统的主服务进程(pid = 1)。 Procd processTODO]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt DHCP - Udhcpc]]></title>
    <url>%2Fposts%2F4d5e1cf%2F</url>
    <content type="text"><![CDATA[PresentationOpenWrt 缺省控制 DHCP 的进程如下： udhcpc - DHCP IPV4 client odhcp6c - DHCP IPV6 client DNSmasq - DHCP IPV4 server odhcpd - DHCP IPV6 server 使用 ps 命令查看 udhcpc 运行参数情况： # ps -w | grep udhcpc udhcpc 运行的参数类似这样： 2339 root 1204 S udhcpc -p /var/run/udhcpc-eth0.2.pid -s /lib/netifd/dhcp.script -f -t 0 -i eth0.2 -x hostname GL-MT300N-V 2674 root 1204 S udhcpc -p /var/run/udhcpc-apcli0.pid -s /lib/netifd/dhcp.script -f -t 0 -i apcli0 -C -O 121 对于我的路由器，当前系统 apcli0 和 eth0.2 网络接口使用了 DHCP 协议，当有 DHCP 事件被触发，会执行 /lib/netifd/dhcp.script 脚本。 Udhcpc startup通过 grep 搜索，发现启动 udhcpc 的代码在 /lib/netifd/proto/dhcp.sh 脚本中，proto_dhcp_setup 函数代码段： proto_run_command "$config" udhcpc \ -p /var/run/udhcpc-$iface.pid \ -s /lib/netifd/dhcp.script \ -f -t 0 -i "$iface" \ ${ipaddr:+-r $ipaddr} \ ${hostname:+-x "hostname:$hostname"} \ ${vendorid:+-V "$vendorid"} \ $clientid $broadcast $release $dhcpopts 这里调用了 proto_run_command 函数，同样地，搜索到它是 /lib/netifd/netifd-proto.sh 提供的脚本 api，代码段： proto_run_command() { local interface="$1"; shift json_init json_add_int action 1 json_add_array command while [ $# -gt 0 ]; do json_add_string "" "$1" shift done json_close_array [ -n "$_EXPORT_VARS" ] &amp;&amp; { json_add_array env for var in $_EXPORT_VARS; do eval "json_add_string \"\" \"\${$var}\"" done json_close_array } _proto_notify "$interface" } proto_run_command 函数就是初始化了json object，往 json object 添加了 string 类型的 action 和 array 类型的 command 字段，把传进来的参数全部填充到 command array中，最后调用了_proto_notify。 _proto_notify 函数代码段： _proto_notify() { local interface="$1" local options="$2" json_add_string "interface" "$interface" ubus $options call network.interface notify_proto "$(json_dump)" } 由此可以看出，最终使用 ubus 把 json 格式的内容发送到 ubusd 处理，network.interface 对象的 notify_proto 方法。 我们可以通过命令行查看 network.interface 对象注册了哪些方法以及怎么使用： # ubus -v list network.interface notify_proto 方法在背后做了哪些工作呢？我们可以通过 netifd 源码来寻找答案。notify_proto 的定义在 ubus.c 文件中，netifd 源码： # git clone git://git.openwrt.org/project/netifd.git static struct ubus_method iface_object_methods[] = { { .name = "up", .handler = netifd_handle_up }, { .name = "down", .handler = netifd_handle_down }, { .name = "renew", .handler = netifd_handle_renew }, { .name = "status", .handler = netifd_handle_status }, { .name = "prepare", .handler = netifd_handle_iface_prepare }, { .name = "dump", .handler = netifd_handle_dump }, UBUS_METHOD("add_device", netifd_iface_handle_device, dev_link_policy ), UBUS_METHOD("remove_device", netifd_iface_handle_device, dev_link_policy ), { .name = "notify_proto", .handler = netifd_iface_notify_proto }, { .name = "remove", .handler = netifd_iface_remove }, { .name = "set_data", .handler = netifd_handle_set_data }, }; 通过跟踪代码，调用顺序大致是这样： netifd_iface_notify_proto --–&gt; iface-&gt;proto-&gt;notify ---&gt; 回调的注册： state-&gt;proto.notify = proto_shell_notify; ---&gt; proto_shell_run_command ---&gt; netifd_start_process ---&gt; 创建子进程调用execvp执行脚本命令 至此，我们可以知道，刚开始分析的 udhcpc 作为脚本 api proto_run_command 的传入参数，最终通过 ubus 通讯，由 netifd 执行 execvp 带起 udhcpc。 Example以重新获取 wan 口的 ip 地址为例演示上面的过程，/lib/netifd/proto/dhcp.sh 的 proto_dhcp_renew 函数可以重新租约 ip 地址，proto_dhcp_renew 函数代码段： proto_dhcp_renew() { local interface="$1" # SIGUSR1 forces udhcpc to renew its lease local sigusr1="$(kill -l SIGUSR1)" [ -n "$sigusr1" ] &amp;&amp; proto_kill_command "$interface" $sigusr1 } proto_dhcp_renew 函数需要接收一个 interface( wan | wan6 | lan | wwan | … ) 参数，重新租约 wan 口的 ip： proto_dhcp_renew "wan" 注意：这里只是为了演示过程，实际上不能直接调用的。 proto_dhcp_renew 调用了 proto_kill_command，代码段： _proto_notify() { local interface="$1" local options="$2" json_add_string "interface" "$interface" ubus $options call network.interface notify_proto "$(json_dump)" } proto_kill_command() { local interface="$1"; shift json_init json_add_int action 2 [ -n "$1" ] &amp;&amp; json_add_int signal "$1" _proto_notify "$interface" } 前面分析可知，这里是构造了一个 json 格式消息，然后通过调用 _proto_notify 把消息发送到 ubusd 处理，这里的 json_dump 内容为： { "interface": "wan", "action": 2, "signal": 16 } proto_dhcp_renew &quot;wan&quot; 其实等价于命令行执行： # ubus call network.interface notify_proto '{"action":2,"signal":16,"interface":"wan"}' Troubleshoot前面提到入口在 /lib/netifd/proto/dhcp.sh 脚本，我们分析一下这个脚本是怎样被执行的？ netifd 主程序是 main.c，netifd 在启动的时候，调用了 proto_shell_init 函数。proto_shell_init 的实现代码以及分析注释： void proto_shell_init(void) { /* 获取 /lib/netifd/proto 文件描述符 */ proto_fd = netifd_open_subdir("proto"); if (proto_fd &lt; 0) return; netifd_init_script_handlers(proto_fd, proto_shell_add_handler); } netifd_init_script_handlers 的实现代码： void netifd_init_script_handlers(int dir_fd, script_dump_cb cb) { glob_t g; int i, prev_fd; prev_fd = netifd_dir_push(dir_fd); if (glob("./*.sh", 0, NULL, &amp;g)) return; for (i = 0; i &lt; g.gl_pathc; i++) netifd_parse_script_handler(g.gl_pathv[i], cb); netifd_dir_pop(prev_fd); globfree(&amp;g); } netifd_parse_script_handler 函数执行 /lib/netifd/proto 目录下的所有.sh文件，dump 作为传入参数。对于dhcp.sh，在脚本执行： init_proto "dump" add_protocol dhcp 其中，init_proto 和 add_protocol 为 netifd-proto.sh 的函数接口。 add_protocol ---&gt; proto_dhcp_init_config 并且构造一个 json 格式消息作为返回，netifd 的 netifd_parse_script_handler 函数将执行 dhcp.sh 脚本的返回值封装成 json 对象。 netifd_init_script_handlers ---&gt; netifd_parse_script_handler ---&gt; netifd_init_script_handler --&gt; proto_shell_add_handler ---&gt; add_proto_handler ---&gt; avl_insert proto_shell_add_handler 是 netifd_init_script_handlers 注册的回调函数，在 netifd_init_script_handler 被调用。proto_shell_add_handler 函数把 json 解析到 struct proto_handler 对应的成员变量中，然后把它插入到 avl 树中。]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - Build]]></title>
    <url>%2Fposts%2F7fbfd015%2F</url>
    <content type="text"><![CDATA[About OpenWrtOpenWrt 是具有高扩展性适合嵌入式设备的 GNU/Linux 发行版，一般应用于无线路由器。OpenWrt build system 包含了 Makefile 及 patch，这一特性大大简化了软件包的移植，交叉编译工具链使用 musl 和 tiny C standard library。 Prerequisites在编译OpenWrt固件之前，需要在宿主主机安装相关的依赖软件包。以Ubuntu 64bit为例： sudo apt-get install build-essential subversion libncurses5-dev zlib1g-dev gawk gcc-multilib flex git-core gettext libssl-dev unzip 其他平台参考：OpenWrt build system – Installation Build firmwareCheckout source如果使用trunk版本，使用下面的命令： git clone https://www.github.com/openwrt/openwrt 如果使用发布版本，使用下面的命令： git clone https://www.github.com/openwrt/openwrt -b chaos_calmer 可以到OpenWrt-github查看当前发布版本！ Update feeds进入刚才用git下载的源码目录，更新OpenWrt的package feeds： cd openwrt ./scripts/feeds update ./scripts/feeds install -a update - 软件包的源位于 ./feeds.conf.default, 可以通过修改这个文件自定义更新软件包的路径。 install - 把 feeds 目录下所有的源创建软链接到 package/feeds 目录。 Make menuconfig选择编译平台： make menuconfig Target System ---&gt; Subtarget ---&gt; Target Profile ---&gt; Build imagemake V=s V=s - 打印编译详细信息。 如果想加快编译速度，对于多核CPU可以加 -j 参数，开启5个线程同时编译： make -j 5 V=s 还可以对输出做重定向处理，把所有输出信息重定向到文件，只打印错误信息： make V=s 2&gt;&amp;1 | tee build.log | grep -i error 注意： 编译过程花费很长的时间，因为 git clone 的只是 OpenWrt 框架，不包含任何软件包的源码，所需的软件包是在编译时下载的，并且存放在 $buildroot/dl 目录下，如果编译由于网络问题导致一些源码包无法下载，我们可以通过浏览器搜索相应的软件包，然后拷贝到 dl 目录，重新编译。 Locate image如果编译无误，最终镜像生成在 $buildroot_dir/bin/$target_platform 目录下。例如 buildroot 目录是 ~/openwrt/，编译的目标平台是ar71xx，则镜像位于： ~/openwrt/bin/ar71xx Clean upmake clean 删除 $buildroot/bin 和 $buildroot/build_dir 目录的内容，但是不会删除交叉编译工具链。 make dirclean 删除 $buildroot/bin、$buildroot/build_dir、$buildroot/staging_dir、 $buildroot/toolchain 和 $buildroot/logs。 make distclean 删除所有内容，包括 feeds 和 dl，还原到 git clone 的状态。]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
</search>
