<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ngrok 内网渗透]]></title>
    <url>%2Fposts%2F9cf8fdeb%2F</url>
    <content type="text"><![CDATA[Ngrok 内网渗透Overview工作原因，偶尔需要在家里远程访问公司的工作站(linux server)。以前使用 ssh tunnel 的方式，但是不稳定，没有重连机制，运行一段时间就挂了。后来使用 teamviewer，图形界面使用 teamviewer 是个不错的选择，但考虑到工作站是 server，并没有图形界面，teamviewer 在这里不适用，还有一点，teamviewer 的密码是动态生成的，也就是说一旦机器重启，即使我设置了开机启动，我也无法远程，因为此时密码已更改。再后来，就搭建了 ngrok 反向代理服务器，感觉挺好用的。 Prerequisitesngrok 有两个版本，v1.x 是开源的，v2.x 是闭源的。我们使用源码编译，ngrok 使用 go 语言实现，我们需要搭建 go 环境。 Install Go$ curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz $ tar xvf go1.6.linux-amd64.tar.gz $ sudo chown -R root:root ./go $ sudo mv go /usr/local Setting Go Paths$ sudo vi ~/.profile 添加环境变量： export PATH=$PATH:/usr/local/go/bin $ source ~/.profile Build NgrokClone Ngrok$ cd ~/ $ git clone https://github.com/inconshreveable/ngrok.git $ cd ~/ngrok Generate Keys$ export NGROK_DOMAIN=&quot;www.21year.cn&quot; $ openssl genrsa -out base.key 2048 $ openssl req -new -x509 -nodes -key base.key -days 10000 -subj &quot;/CN=$NGROK_DOMAIN&quot; -out rootCA.pem $ openssl genrsa -out server.key 2048 $ openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csr $ openssl x509 -req -in server.csr -CA rootCA.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt $ cp rootCA.pem assets/client/tls/ngrokroot.crt -i $ cp server.crt assets/server/tls/snakeoil.crt -i $ cp server.key assets/server/tls/snakeoil.key -i Build Server and Client$ export GOPATH=~/ngrok/ $ make release-server $ make release-client Ngrok ConfigurationVPS 服务器需要备案，因为要用到域名，这里，我的域名为 “www.21year.cn”。 Run Server$ sudo cp ~/ngrok/bin/ngrokd /usr/bin/ $ sudo ngrokd -domain=&quot;www.21year.cn&quot; -httpAddr=&quot;:80&quot; -httpsAddr=&quot;:443&quot; Run Client把编译好的 ngrok 程序传送到客户端(家里的虚拟机) /usr/bin 目录下，然后开始配置。 $ sudo vi /etc/ngrok.yml ngrok.yml 配置文件的内容： server_addr: www.21year.cn:4443 trust_host_root_certs: false tunnels: ssh: remote_port: 10086 proto: tcp: 22 启动 ngrok client： sudo ngrok -config=/etc/ngrok.yml start ssh Remote SSH服务器和客户端都运行后，可以通过 ssh 远程到内网工作站了。根据我的配置，代理端口为 10086，使用 ssh 远程： $ ssh kyson@www.21year.cn -p 10086]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - Make Image]]></title>
    <url>%2Fposts%2F65688acd%2F</url>
    <content type="text"><![CDATA[OpenWrt 制作 bin 固件Commandmake target/linux/install V=s 源码分析Target Makefiletarget/linux 的 Makefile 代码： # # Copyright (C) 2006-2007 OpenWrt.org # # This is free software, licensed under the GNU General Public License v2. # See /LICENSE for more information. # include $(TOPDIR)/rules.mk include $(INCLUDE_DIR)/target.mk export TARGET_BUILD=1 prereq clean download prepare compile install menuconfig nconfig oldconfig update refresh: FORCE @+$(NO_TRACE_MAKE) -C $(BOARD) $@ prereq clean download prepare compile install menuconfig nconfig oldconfig update refresh 这一系列的 makefile target 真正的实现位于 include/kernel-build.mk 的 BuildKernel 函数，下面会分析。$(BOARD) 变量为 CONFIG_TARGET_BOARD，如 ar71xx 平台，$(BOARD) 为 “ar71xx”。由上面的代码可以看出，这里切换到了 $(BOARD) 目录，执行 $(BOARD) 目录下的 Makefile。 Subtarget Makefiletarget/linux/ar71xx/Makefile 代码： # # Copyright (C) 2008-2011 OpenWrt.org # # This is free software, licensed under the GNU General Public License v2. # See /LICENSE for more information. # include $(TOPDIR)/rules.mk ARCH:=mips BOARD:=ar71xx BOARDNAME:=Atheros AR7xxx/AR9xxx FEATURES:= CPU_TYPE:=24kc SUBTARGETS:=generic nand mikrotik KERNEL_PATCHVER:=4.4 include $(INCLUDE_DIR)/target.mk DEFAULT_PACKAGES += \ kmod-gpio-button-hotplug swconfig \ kmod-ath9k wpad-mini uboot-envtools $(eval $(call BuildTarget)) 这里调用了 BuildTarget 函数，根据它包含了 target.mk，猜测其定义位于 include/target.mk，找到代码段： ifeq ($(TARGET_BUILD),1) include $(INCLUDE_DIR)/kernel-build.mk BuildTarget?=$(BuildKernel) endif 同样的思路，找到 BuildKernel 函数的定义位于 include/kernel-build.mk： define BuildKernel download: ... prepare: ... compile: ... oldconfig menuconfig nconfig: ... install: ... clean: ... ... endef 这里，可以看到前面说的那一系列 target 的原型。也就是说，执行 make target/linux/install，最终执行 include/kernel-build.mk 中的 BuildKernel 下的 install。 以 install 为例，继续分析，install 在 BuildKernel 的定义代码： install: $(LINUX_DIR)/.image +$(MAKE) -C image compile install TARGET_BUILD= 这里又调用了 image 的子 Makefile，执行 make -C target/linux/$(BOARD)/image compile install TARGET_BUILD=。 Image Makefiletarget/linux/ar71xx/image/Makefile 代码段： define Device/Default BOARDNAME := DEVICE_PROFILE = $$(BOARDNAME) PROFILES = Default Minimal $$(DEVICE_PROFILE) MTDPARTS := BLOCKSIZE := 64k CONSOLE = ttyS0,115200 CMDLINE = $$(if $$(BOARDNAME),board=$$(BOARDNAME)) $$(if $$(MTDPARTS),mtdparts=$$(MTDPARTS)) $$(if $$(CONSOLE),console=$$(CONSOLE)) KERNEL := kernel-bin | patch-cmdline | lzma | uImage lzma COMPILE := IMAGES := sysupgrade.bin IMAGE/sysupgrade.bin = append-kernel | pad-to $$$$(BLOCKSIZE) | append-rootfs | pad-rootfs | check-size $$$$(IMAGE_SIZE) endef $(eval $(call BuildImage)) 它调用了BuildImage 函数，关于 Device/Default 后面分析，BuildImage定义位于 include/image.mk： define BuildImage download: prepare: compile: clean: legacy-images-prepare: legacy-images: image_prepare: ... endef 这里也是定义了 image 目录 Makefile 的 target 原型。 compile 编译 vmlinux，install 压缩 vmlinux，制作文件系统，patch-cmdline，padjffs2 处理，最终生成 .bin 固件。install 以及其依赖的定义： kernel_prepare: image_prepare $(call Image/Build/targz) $(call Image/Build/cpiogz) $(call Image/BuildKernel) $(if $(CONFIG_TARGET_ROOTFS_INITRAMFS),$(if $(IB),,$(call Image/BuildKernel/Initramfs))) $(call Image/InstallKernel) $(foreach device,$(TARGET_DEVICES),$(call Device,$(device))) $(foreach device,$(LEGACY_DEVICES),$(call LegacyDevice,$(device))) install-images: kernel_prepare $(foreach fs,$(filter-out $(if $(UBIFS_OPTS),,ubifs),$(TARGET_FILESYSTEMS) $(fs-subtypes-y)),$(KDIR)/root.$(fs)) $(foreach fs,$(TARGET_FILESYSTEMS),$(call Image/Build,$(fs))) install: install-images $(call Image/Manifest) 我一开始比较疑惑的是 kernel-bin | patch-cmdline | lzma | uImage | padjffs2 | sysupgrade.bin 这一系列的操作是怎么执行的？它们的默认定义位于各目标板的 image 目录下，target/linux/ar71xx/image/Makefile： define Device/Default BOARDNAME := DEVICE_PROFILE = $$(BOARDNAME) PROFILES = Default Minimal $$(DEVICE_PROFILE) MTDPARTS := BLOCKSIZE := 64k CONSOLE = ttyS0,115200 CMDLINE = $$(if $$(BOARDNAME),board=$$(BOARDNAME)) $$(if $$(MTDPARTS),mtdparts=$$(MTDPARTS)) $$(if $$(CONSOLE),console=$$(CONSOLE)) KERNEL := kernel-bin | patch-cmdline | lzma | uImage lzma COMPILE := IMAGES := sysupgrade.bin IMAGE/sysupgrade.bin = append-kernel | pad-to $$$$(BLOCKSIZE) | append-rootfs | pad-rootfs | check-size $$$$(IMAGE_SIZE) endef 我们分析一下 KERNEL 这个变量，它定义的几个操作原型位于 include/image-commands.mk： ... define Build/kernel-bin rm -f $@ cp $&lt; $@ endef define Build/patch-cmdline $(STAGING_DIR_HOST)/bin/patch-cmdline $@ &apos;$(CMDLINE)&apos; endef define Build/lzma $(call Build/lzma-no-dict,-lc1 -lp2 -pb2 $(1)) endef define Build/uImage mkimage -A $(LINUX_KARCH) \ -O linux -T kernel \ -C $(1) -a $(KERNEL_LOADADDR) -e $(if $(KERNEL_ENTRY),$(KERNEL_ENTRY),$(KERNEL_LOADADDR)) \ -n &apos;$(if $(UIMAGE_NAME),$(UIMAGE_NAME),$(call toupper,$(LINUX_KARCH)) LEDE Linux-$(LINUX_VERSION))&apos; -d $@ $@.new @mv $@.new $@ endef ... 在 include/image.mk 调用： ... define Device/Build/kernel $(KDIR)/$$(KERNEL_NAME):: image_prepare $$(_TARGET): $$(if $$(KERNEL_INSTALL),$(BIN_DIR)/$$(KERNEL_IMAGE)) $(call Device/Export,$$(KDIR_KERNEL_IMAGE),$(1)) $(BIN_DIR)/$$(KERNEL_IMAGE): $$(KDIR_KERNEL_IMAGE) cp $$^ $$@ ifndef IB ifdef CONFIG_IB install: $$(KDIR_KERNEL_IMAGE) endif $$(KDIR_KERNEL_IMAGE): $(KDIR)/$$(KERNEL_NAME) $(CURDIR)/Makefile $$(KERNEL_DEPENDS) image_prepare @rm -f $$@ $$(call concat_cmd,$$(KERNEL)) $$(if $$(KERNEL_SIZE),$$(call Build/check-size,$$(KERNEL_SIZE))) endif endef ... $$(call concat_cmd,$$(KERNEL)) 逐个处理。 总结make[2] target/install make[3] -C target/linux install make[6] -C target/linux/ar71xx/image legacy-images-prepare make[6] -C target/linux/ar71xx/image/lzma-loader compile loader.elf]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - Buildroot Package Install]]></title>
    <url>%2Fposts%2Fbb404976%2F</url>
    <content type="text"><![CDATA[Buildroot Package InstallBuild Log通过 make V=s 打印详细的编译信息，打包过程的信息如下： /home/kyson/workspace/devlop/tests/lede-17.01_build/staging_dir/host/bin/opkg \ --offline-root /home/kyson/workspace/devlop/tests/lede-17.01_build/build_dir/\ target-mips_24kc_musl-1.1.16/root-ar71xx \ --add-dest root:/ \ --add-arch all:100 \ --add-arch mips_24kc:200 \ install base-files_173.1-r3600-18b8cfd_mips_24kc.ipk xxx.ipk ... 简化路径，以下 $(BUILD_ROOT) 表示 OpenWrt 源码的根目录： $(BUILD_ROOT)/staging_dir/host/bin/opkg \ --offline-root $(BUILD_ROOT)/build_dir/target-mips_24kc_musl-1.1.16/root-ar71xx \ --force-postinstall \ --add-dest root:/ \ --add-arch all:100 \ --add-arch mips_24kc:200 \ install base-files_173.1-r3600-18b8cfd_mips_24kc.ipk xxx.ipk ... Opkg Definitionpackage install 的定义位于 package/Makefile： $(curdir)/install: $(TMP_DIR)/.build $(curdir)/system/opkg/host/compile $(curdir)/merge $(if $(CONFIG_TARGET_PER_DEVICE_ROOTFS),$(curdir)/merge-index) - find $(STAGING_DIR_ROOT) -type d | $(XARGS) chmod 0755 rm -rf $(TARGET_DIR) $(TARGET_DIR_ORIG) [ -d $(TARGET_DIR)/tmp ] || mkdir -p $(TARGET_DIR)/tmp $(call opkg,$(TARGET_DIR)) install \ $(call opkg_package_files,$(shell cat $(PACKAGE_INSTALL_FILES) 2&gt;/dev/null)) @for file in $(PACKAGE_INSTALL_FILES); do \ [ -s $$file.flags ] || continue; \ for flag in `cat $$file.flags`; do \ $(call opkg,$(TARGET_DIR)) flag $$flag `cat $$file`; \ done; \ done || true @-$(MAKE) package/preconfig $(CP) $(TARGET_DIR) $(TARGET_DIR_ORIG) $(call prepare_rootfs,$(TARGET_DIR)) 我们关心的代码段： $(call opkg,$(TARGET_DIR)) install \ $(call opkg_package_files,$(shell cat $(PACKAGE_INSTALL_FILES) 2&gt;/dev/null)) 这个代码分别调用了 opkg 和 opkg_package_files，这里我们把它们理解为 makefile 函数，opkg 主要调用了 opkg 命令，并且加上一些必要的参数，opkg_package_files 搜集所有的 ipk。 opkg 的定义位于 include/rootfs.mk： # where to build (and put) .ipk packages # $(1) = $(TARGET_DIR), TARGET_DIR:=$(TARGET_ROOTFS_DIR)/root-$(BOARD) opkg = \ IPKG_NO_SCRIPT=1 \ IPKG_INSTROOT=$(1) \ TMPDIR=$(1)/tmp \ $(STAGING_DIR_HOST)/bin/opkg \ --offline-root $(1) \ --force-postinstall \ --add-dest root:/ \ --add-arch all:100 \ --add-arch $(if $(ARCH_PACKAGES),$(ARCH_PACKAGES),$(BOARD)):200 opkg_package_files 的定义位于 include/feeds.mk： opkg_package_files = $(wildcard \ $(foreach dir,$(PACKAGE_SUBDIRS), \ $(foreach pkg,$(1), $(dir)/$(pkg)_*.ipk)))]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac80211 - MT76 Driver Initialization]]></title>
    <url>%2Fposts%2F87b631c2%2F</url>
    <content type="text"><![CDATA[MT76 Driver InitializationOverviewMT76 是基于 mac80211 框架实现的 MediaTek MT76x2 802.11ac 开源无线驱动，包含了 mt76 core 驱动，以及 mt7603.ko 2.4GHz 驱动和 mt76x2e.ko 5GHz 驱动。mt7628 WIFI 驱动使用的是 mt7603.ko，不稳定，吞吐量也很低，而 mt7620 WIFI 驱动使用的是 mac80211 框架里面已经实现的 rt2800-soc 驱动，较稳定些。本文主要分析 mt7603.ko 的初始化过程，其他的思路差不多。 Initializationmt7603_init驱动加载的入口位于文件 mt7603_main.c： static int __init mt7603_init(void) { int ret; ret = platform_driver_register(&amp;mt76_wmac_driver); if (ret) return ret; #ifdef CONFIG_PCI ret = pci_register_driver(&amp;mt7603_pci_driver); if (ret) platform_driver_unregister(&amp;mt76_wmac_driver); #endif return ret; } module_init(mt7603_init); module_exit(mt7603_exit); 通过上面的代码段可以看出，如果使用 PCI 总线，调用 pci_register_driver 注册到 PCI 总线，默认使用 platform 虚拟平台总线，调用platform_driver_register 注册到 platform 总线。由于我们使用 mt7628 作为主芯片，使用的是 platform 总线，下面以 platform 总线为例进行分析。 platform driverplatform driver 结构体： static const struct of_device_id of_wmac_match[] = { { .compatible = "mediatek,mt7628-wmac" }, {}, }; struct platform_driver mt76_wmac_driver = { .probe = mt76_wmac_probe, .remove = mt76_wmac_remove, .driver = { .name = "mt76_wmac", /* 设备树匹配 */ .of_match_table = of_wmac_match, }, }; mt76_wmac_probe驱动的真正入口 mt76_wmac_probe，代码段解析： static int mt76_wmac_probe(struct platform_device *pdev) { /* 获取设备的物理信息 */ struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0); /* 通过查找 pdev 获得设备触发中断资源 */ irq = platform_get_irq(pdev, 0); /* io资源到内核地址的映射 */ mem_base = devm_ioremap_resource(&amp;pdev-&gt;dev, res); /** * mt7603_alloc_device: 为设备分配内存空间，进行初始化，提供底层的驱动回调函数， * 并调用了 mac80211 框架的接口 ==&gt; ieee80211_alloc_hw * * 每个 driver 调用 ieee80211_alloc_hw 分配 ieee80211_hw，且以 ieee80211_ops 为参数 **/ dev = mt7603_alloc_device(&amp;pdev-&gt;dev); /** * 初始化 MMIO(Memory-mapped I/O) * * 主要是提供几个读写寄存器相关的回调函数 * * static const struct mt76_bus_ops mt76_mmio_ops = { * .rr = mt76_mmio_rr, * .rmw = mt76_mmio_rmw, * .wr = mt76_mmio_wr, * .copy = mt76_mmio_copy, * }; * * dev-&gt;bus = &amp;mt76_mmio_ops; * dev-&gt;regs = regs; * mt76_mmio_init(&amp;dev-&gt;mt76, mem_base); */ /* * revision 版本号 * * 高两位： 0x10300000 + 0x1008 * 低两位： 0x10300000 + 0x1000 * * 这两个寄存器偏移值是从 MediaTek mt7628 闭源 WIFI 驱动源码得知，位于 rt2880_module_init 函数 * * RTMP_IO_READ32(pAd, TOP_HVR, &amp;Value); /* #define TOP_HVR 0x1000 */ * pAd-&gt;HWVersion = Value; * /* (pAd-&gt;HWVersion &amp; 0x0000ffff) == 0x8A00 MT7628_e1.bin */ * /* (pAd-&gt;HWVersion &amp; 0x0000ffff) == 0x8A01 MT7628_e2.bin */ * * RTMP_IO_READ32(pAd, TOP_FVR, &amp;Value); /* #define TOP_FVR 0x1004 */ * pAd-&gt;FWVersion = Value; * * RTMP_IO_READ32(pAd, TOP_HCR, &amp;Value); /* #define TOP_HCR 0x1008 */ * pAd-&gt;ChipID = Value; * /* 芯片id号 */ */ dev-&gt;mt76.rev = (mt76_rr(dev, MT_HW_CHIPID) &lt;&lt; 16) | (mt76_rr(dev, MT_HW_REV) &amp; 0xff); /* 注册中断回调 */ ret = devm_request_irq(dev-&gt;mt76.dev, irq, mt7603_irq_handler, IRQF_SHARED, KBUILD_MODNAME, dev); /* 注册设备，下面分析这个函数 */ ret = mt7603_register_device(dev); return 0; error: ieee80211_free_hw(mt76_hw(dev)); return ret; } mt7603_register_devicemt7603_register_device 函数代码段： int mt7603_register_device(struct mt7603_dev *dev) { /* * 在 probe 里面调用的 mt7603_alloc_device 为驱动分配 ieee80211_hw，这里的 hw 指针 * 指向了它，是为了操作 ieee80211_hw 的成员变量 wiphy */ struct ieee80211_hw *hw = mt76_hw(dev); struct wiphy *wiphy = hw-&gt;wiphy; /* 初始化互斥锁、自旋锁和工作队列 */ mutex_init(&amp;dev-&gt;mutex); spin_lock_init(&amp;dev-&gt;status_lock); __skb_queue_head_init(&amp;dev-&gt;status_list); INIT_DELAYED_WORK(&amp;dev-&gt;mac_work, mt7603_mac_work); tasklet_init(&amp;dev-&gt;pre_tbtt_tasklet, mt7603_pre_tbtt_tasklet, (unsigned long) dev); /* 初始化，下面分析这个函数 */ ret = mt7603_init_hardware(dev); /** * 绑定interface * * ADHOC 类型 interface 最大限制是1 * STATION | MESH_POINT | AP 类型 interface 最大限制是4 */ wiphy-&gt;iface_combinations = if_comb; wiphy-&gt;n_iface_combinations = ARRAY_SIZE(if_comb); ieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS); /** * 这个函数进行了一系列的 ieee80211_hw_set 操作，主要是控制 rate * * 5种调制 Mode * CCK: * OFDM: * HT: * HT_GF: * VHT: 5GHz band 独有的 */ ret = mt76_register_device(&amp;dev-&gt;mt76, true, mt7603_rates, ARRAY_SIZE(mt7603_rates)); /* mt7603 驱动初始化完成 */ } 802.11 协议对应的调制格式如图所示： mt7603_init_hardwaremt7603_init_hardware 函数代码段： static int mt7603_init_hardware(struct mt7603_dev *dev) { mt76_wr(dev, MT_INT_SOURCE_CSR, ~0); /** * mt7603_eeprom_init 函数的代码段： * * /* 加载 eeprom*/ * ret = mt7603_eeprom_load(dev); * /* 检测读取的 flash 前面两个字节是否为 0x7628 | 0x7603，不是的话，拷贝 efuse到 dev-&gt;mt76.eeprom.data */ * if (mt7603_check_eeprom(&amp;dev-&gt;mt76) == 0) * mt7603_apply_cal_free_data(dev, dev-&gt;mt76.otp.data); * else * memcpy(dev-&gt;mt76.eeprom.data, dev-&gt;mt76.otp.data, MT7603_EEPROM_SIZE); * * /* 偏移 0x4 位置为 macaddress */ * memcpy(dev-&gt;mt76.macaddr, dev-&gt;mt76.eeprom.data + MT_EE_MAC_ADDR, ETH_ALEN); * * mt76_eeprom_override(&amp;dev-&gt;mt76); * * ============================================================================ * * mt7603_eeprom_load 函数分配空间，调用 mt76_get_of_eeprom 函数，只有定义了设备树才 * 有效，mt76_get_of_eeprom 函数的代码段解析： * * /* device tree 的 wmac 节点 */ * struct device_node *np = dev-&gt;dev-&gt;of_node; * * /* wmac 节点的 mediatek,mtd-eeprom 属性 */ * list = of_get_property(np, "mediatek,mtd-eeprom", &amp;size); * * /* wmac 节点的 label 属性，找不到就用 np-&gt;name，即 wmac */ * part = of_get_property(np, "label", NULL); * * /* 根据 part 名找 mtd 分区号 */ * mtd = get_mtd_device_nm(part); * * /* 读 mtd 分区，即flash 校准区内容，存放到 dev-&gt;eeprom.data */ * ret = mtd_read(mtd, offset, len, &amp;retlen, dev-&gt;eeprom.data); */ ret = mt7603_eeprom_init(dev); ret = mt7603_dma_init(dev); mt76_wr(dev, MT_WPDMA_GLO_CFG, 0x52000850); mt7603_mac_dma_start(dev); dev-&gt;rxfilter = mt76_rr(dev, MT_WF_RFCR); set_bit(MT76_STATE_INITIALIZED, &amp;dev-&gt;mt76.state); /* 加载设备固件，调用了 mt7603_load_firmware 函数 */ ret = mt7603_mcu_init(dev); mt7603_dma_sched_init(dev); mt7603_mcu_set_eeprom(dev); mt7603_phy_init(dev); mt7603_mac_init(dev); } mt7603_load_firmwaremt7603_load_firmware 函数代码段： static int mt7603_load_firmware(struct mt7603_dev *dev) { /** * 定义： include/linux/firmware.h * * struct firmware { * size_t size; * const u8 *data; * struct page **pages; * * /* firmware loader private fields */ * void *priv; * }; */ const struct firmware *fw; const struct mt7603_fw_trailer *hdr; const char *firmware; int dl_len; u32 addr, val; int ret; if (is_mt7628(dev)) { if (mt76xx_rev(dev) == MT7628_REV_E1) firmware = MT7628_FIRMWARE_E1; else firmware = MT7628_FIRMWARE_E2; } else { if (mt76xx_rev(dev) &lt; MT7603_REV_E2) firmware = MT7603_FIRMWARE_E1; else firmware = MT7603_FIRMWARE_E2; } ret = request_firmware(&amp;fw, firmware, dev-&gt;mt76.dev); if (ret) return ret; if (!fw || !fw-&gt;data || fw-&gt;size &lt; sizeof(*hdr)) { dev_err(dev-&gt;mt76.dev, "Invalid firmware\n"); ret = -EINVAL; goto out; } hdr = (const struct mt7603_fw_trailer *) (fw-&gt;data + fw-&gt;size - sizeof(*hdr)); dev_info(dev-&gt;mt76.dev, "Firmware Version: %.10s\n", hdr-&gt;fw_ver); dev_info(dev-&gt;mt76.dev, "Build Time: %.15s\n", hdr-&gt;build_date); addr = mt7603_reg_map(dev, 0x50012498); mt76_wr(dev, addr, 0x5); mt76_wr(dev, addr, 0x5); udelay(1); /* switch to bypass mode */ mt76_rmw(dev, MT_SCH_4, MT_SCH_4_FORCE_QID, MT_SCH_4_BYPASS | FIELD_PREP(MT_SCH_4_FORCE_QID, 5)); val = mt76_rr(dev, MT_TOP_MISC2); if (val &amp; BIT(1)) { dev_info(dev-&gt;mt76.dev, "Firmware already running...\n"); goto running; } if (!mt76_poll_msec(dev, MT_TOP_MISC2, BIT(0) | BIT(1), BIT(0), 500)) { dev_err(dev-&gt;mt76.dev, "Timeout waiting for ROM code to become ready\n"); ret = -EIO; goto out; } dl_len = le32_to_cpu(hdr-&gt;dl_len) + 4; ret = mt7603_mcu_init_download(dev, MCU_FIRMWARE_ADDRESS, dl_len); if (ret) { dev_err(dev-&gt;mt76.dev, "Download request failed\n"); goto out; } ret = mt7603_mcu_send_firmware(dev, fw-&gt;data, dl_len); if (ret) { dev_err(dev-&gt;mt76.dev, "Failed to send firmware to device\n"); goto out; } ret = mt7603_mcu_start_firmware(dev, MCU_FIRMWARE_ADDRESS); if (ret) { dev_err(dev-&gt;mt76.dev, "Failed to start firmware\n"); goto out; } if (!mt76_poll_msec(dev, MT_TOP_MISC2, BIT(1), BIT(1), 500)) { dev_err(dev-&gt;mt76.dev, "Timeout waiting for firmware to initialize\n"); ret = -EIO; goto out; } running: mt76_clear(dev, MT_SCH_4, MT_SCH_4_FORCE_QID | MT_SCH_4_BYPASS); mt76_set(dev, MT_SCH_4, BIT(8)); mt76_clear(dev, MT_SCH_4, BIT(8)); dev-&gt;mcu.running = true; printk("firmware init done\n"); out: release_firmware(fw); return ret; } mt76_eeprom_overridemt76_eeprom_override 函数是从设备树获取 macaddress，如果没有在设备树给定则随机生成，函数代码段： void mt76_eeprom_override(struct mt76_dev *dev) { #ifdef CONFIG_OF struct device_node *np = dev-&gt;dev-&gt;of_node; const u8 *mac; if (!np) return; /** * 设备树获取 macaddress, of_get_mac_address 函数的定义： * * const void *of_get_mac_address(struct device_node *np) * { * const void *addr; * * addr = of_get_mac_addr(np, "mac-address"); * if (addr) * return addr; * * addr = of_get_mac_addr(np, "local-mac-address"); * if (addr) * return addr; * * return of_get_mac_addr(np, "address"); * } */ mac = of_get_mac_address(np); if (mac) memcpy(dev-&gt;macaddr, mac, ETH_ALEN); #endif if (!is_valid_ether_addr(dev-&gt;macaddr)) { eth_random_addr(dev-&gt;macaddr); dev_info(dev-&gt;dev, "Invalid MAC address, using random address %pM\n", dev-&gt;macaddr); } }]]></content>
      <categories>
        <category>Mac80211</category>
      </categories>
      <tags>
        <tag>mac80211</tag>
        <tag>mt76</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Tools - Submodules]]></title>
    <url>%2Fposts%2Ffe519d8%2F</url>
    <content type="text"><![CDATA[Git 嵌套Overview我们的工程可能需要用到第三方的库，以前我们一般都是通过引用动态库或者直接拷贝依赖库的源码到当前工程源码树，这样很难保证所有的客户端使用同一版本的动态库，并且一旦修改了库的内容，我们没有办法把新的 changes 合并进来。Git 提供了 submodules 解决了这个问题，它允许 git repository 嵌套子 git repository。 Starting with Submodules为了方便演示，我在内部 git server 创建了连个 demo repository： $ git@192.168.16.16:luoweilong/main_test.git $ git@192.168.16.16:luoweilong/test.git git submodule 命令手册： kyson@gl-inet:~$ git submodule help usage: git submodule [--quiet] add [-b &lt;branch&gt;] [-f|--force] [--name &lt;name&gt;] [--reference &lt;repository&gt;] [--] &lt;repository&gt; [&lt;path&gt;] or: git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;...] or: git submodule [--quiet] init [--] [&lt;path&gt;...] or: git submodule [--quiet] deinit [-f|--force] [--] &lt;path&gt;... or: git submodule [--quiet] update [--init] [--remote] [-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--reference &lt;repository&gt;] [--recursive] [--] [&lt;path&gt;...] or: git submodule [--quiet] summary [--cached|--files] [--summary-limit &lt;n&gt;] [commit] [--] [&lt;path&gt;...] or: git submodule [--quiet] foreach [--recursive] &lt;command&gt; or: git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;...] 我们可以使用 git submodule add 命令在已存的 git repo 添加 submodule，如我在 main_test 工程添加 test 模块： $ git submodule add git@192.168.16.16:luoweilong/test.git Cloning into &apos;test&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. Checking connectivity... done. 缺省情况，submodules 会以 repo 名作为子工程目录名，这个跟 git clone是一样的，后面可以跟个目录名参数。添加子模块后，会把信息写到 .gitmodules 文件，内容如下： $ cat .gitmodules [submodule &quot;test&quot;] path = test url = git@192.168.16.16:luoweilong/test.git Note: Since the URL in the .gitmodules file is what other people will first try to clone/fetch from, make sure to use a URL that they can access if possible. For example, if you use a different URL to push to than others would to pull from, use the one that others have access to. You can overwrite this value locally with git config submodule.DbConnector.url PRIVATE_URL for your own use. When applicable, a relative URL can be helpful. 提交 commit： $ git add . $ git status On branch master Your branch is up-to-date with &apos;origin/master&apos;. Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: .gitmodules new file: test $git commit -m &quot;add submodules&quot; [master f95257a] add submodules 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 test $ git push -u origin master Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 373 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@192.168.16.16:luoweilong/main_test.git 017982e..f95257a master -&gt; master Branch master set up to track remote branch master from origin. Cloning a Project with Submodules克隆带 submodules 的工程到本地： $ git clone git@192.168.16.16:luoweilong/main_test.git Cloning into &apos;main_test&apos;... remote: Counting objects: 6, done. remote: Compressing objects: 100% (4/4), done. remote: Total 6 (delta 0), reused 0 (delta 0) Receiving objects: 100% (6/6), done. Checking connectivity... done. $ cd main_test/ $ ll total 20 drwxrwxr-x 4 kyson kyson 4096 11月 21 12:38 ./ drwxrwxrwt 72 root root 4096 11月 21 12:38 ../ drwxrwxr-x 8 kyson kyson 4096 11月 21 12:38 .git/ -rw-rw-r-- 1 kyson kyson 77 11月 21 12:38 .gitmodules -rw-rw-r-- 1 kyson kyson 0 11月 21 12:38 README drwxrwxr-x 2 kyson kyson 4096 11月 21 12:38 test/ 我们可以看到 test 目录，但是这个目录空的，需要执行 git submodule init 初始化本地配置文件 和 git submodule update 获取所有的数据和切换到合适的 commit。 $ git submodule init Submodule &apos;test&apos; (git@192.168.16.16:luoweilong/test.git) registered for path &apos;test&apos; $ git submodule update Cloning into &apos;test&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. Checking connectivity... done. Submodule path &apos;test&apos;: checked out &apos;3d9f6ed6d00a2767307505710e72298ec078afdf&apos; $ tree . ├── README └── test └── README 1 directory, 2 files 我们可以在克隆的时候加上 –recursive 参数，它会自动初始化和更新工程的 submodule。 $ git clone --recursive git@192.168.16.16:luoweilong/main_test.git Working on a Project with SubmodulesPublishing Submodule Changes首先我们需要进入 submodule 目录，切换到需要更改的分支，然后更新代码，以 test 的 master分支为例： $ cd test/ $ git branch --remote origin/HEAD -&gt; origin/master origin/master $ git branch * (HEAD detached at 3d9f6ed) master $ git checkout master $ git submodule update --remote --merge 进入 submodule 目录修改 repo 内容，然后 commit： $ cd test/ $ vi test.c $ git add . $ git commit -m &quot;add test.c&quot; 切换回到 main_test，提交 commit，然后递归子模块 push： $ cd ../ $ git add . $ git commit &quot;modify submodule&quot; $ git push --recurse-submodules=on-demand Pushing submodule &apos;test&apos; Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 286 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@192.168.16.16:luoweilong/test.git 3d9f6ed..7d4593b master -&gt; master Counting objects: 2, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (2/2), 241 bytes | 0 bytes/s, done. Total 2 (delta 1), reused 0 (delta 0) To git@192.168.16.16:luoweilong/main_test.git 051b3eb..3bf539b master -&gt; master 我们可以看到，test repo 和 main_test repo 都 push 了。 为了简化 git push，可以把它写到配置： $ git config push.recurseSubmodules on-demand $ git push Pulling in Upstream Changes更新主工程，在更新 submodule： $ git pull $ git submodule update]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - Feeds Script]]></title>
    <url>%2Fposts%2F6da41d62%2F</url>
    <content type="text"><![CDATA[How feeds worksFeeds Command optionfeeds 命令选项： my %commands = ( &apos;list&apos; =&gt; \&amp;list, &apos;update&apos; =&gt; \&amp;update, &apos;install&apos; =&gt; \&amp;install, &apos;search&apos; =&gt; \&amp;search, &apos;uninstall&apos; =&gt; \&amp;uninstall, &apos;feed_config&apos; =&gt; \&amp;feed_config, &apos;clean&apos; =&gt; sub { system(&quot;rm -rf ./feeds ./package/feeds&quot;); } ); Feeds Update./scripts/feeds update -a update 函数代码段： sub update { # 解析参数 -a | -i | -f # -a : Update all feeds listed within feeds.conf. Otherwise the specified feeds will be updated. # -i : Recreate the index only. No feed update from repository is performed. # -f : Force updating feeds even if there are changed, uncommitted files. # 如果指定 —i,不使能 update $perform_update=0; # 判断 feeds 目录是否存在，不存在创建 -d "feeds" or do { mkdir "feeds" or die "Unable to create the feeds directory"; }; # 没有指定参数，或者参数为 -a，更新所有 feeds，否则根据给定的 feed_name 更新 if ( ($#ARGV == -1) or $opts{a}) { foreach my $feed (@feeds) { my ($type, $name, $src) = @$feed; update_feed($type, $name, $src, $perform_update, $opts{f}) == 0 or $failed=1; } } else { while ($feed_name = shift @ARGV) { foreach my $feed (@feeds) { my ($type, $name, $src) = @$feed; if($feed_name ne $name) { next; } update_feed($type, $name, $src, $perform_update, $opts{f}) == 0 or $failed=1; } } } # 如果没有 .config，创建 .config refresh_config(); } update_feed 函数代码段： sub update_feed($$$$$) { # 提取参数 my $type=shift; my $name=shift; my $src=shift; my $perform_update=shift; my $force_update=update_location( $name, "@$src" ); # 创建./feeds/xxx.tmp/location # 检测是否支持 feeds.conf.default 给定的类型[git-src|svn|...] $update_method{$type} or do { warn "Unknown type '$type' in feed $name\n"; return 1; }; # 如果没有通过 -i 不使能 update，则会调用 update_feed_via()，克隆repo foreach my $feedsrc (@$src) { warn "Updating feed '$name' from '$feedsrc' ...\n"; if (update_feed_via($type, $name, $feedsrc, $force_relocate, $force_update) != 0) { if ($force_update) { $rv=1; $failed=0; warn "failed, ignore.\n"; next; } last; } $failed = 0; } # 创建 index 索引表(软链接到xxx.tmp/.packageinfo)，这个函数执行了include/scan.mk，并 update_index($name) == 0； } update_index 函数代码段： sub update_index($) { my $name = shift; -d "./feeds/$name.tmp" or mkdir "./feeds/$name.tmp" or return 1; -d "./feeds/$name.tmp/info" or mkdir "./feeds/$name.tmp/info" or return 1; system("$mk -s prepare-mk OPENWRT_BUILD= TMP_DIR=\"$ENV{TOPDIR}/feeds/$name.tmp\""); system("$mk -s -f include/scan.mk IS_TTY=1 SCAN_TARGET=\"packageinfo\" SCAN_DIR=\"feeds/$name\" SCAN_NAME=\"package\" SCAN_DEPS=\"$ENV{TOPDIR}/include/package*.mk\" SCAN_DEPTH=5 SCAN_EXTRA=\"\" TMP_DIR=\"$ENV{TOPDIR}/feeds/$name.tmp\""); system("$mk -s -f include/scan.mk IS_TTY=1 SCAN_TARGET=\"targetinfo\" SCAN_DIR=\"feeds/$name\" SCAN_NAME=\"target\" SCAN_DEPS=\"profiles/*.mk $ENV{TOPDIR}/include/target.mk\" SCAN_DEPTH=5 SCAN_EXTRA=\"\" SCAN_MAKEOPTS=\"TARGET_BUILD=1\" TMP_DIR=\"$ENV{TOPDIR}/feeds/$name.tmp\""); system("ln -sf $name.tmp/.packageinfo ./feeds/$name.index"); system("ln -sf $name.tmp/.targetinfo ./feeds/$name.targetindex"); return 0; } feeds软链接的情况： kyson@gl-inet:~/workspace/devlop/gli/openwrt-cc$ ls -l feeds/ total 56 drwxrwxr-x 11 kyson kyson 4096 11月 16 17:19 luci lrwxrwxrwx 1 kyson kyson 21 11月 16 17:19 luci.index -&gt; luci.tmp/.packageinfo lrwxrwxrwx 1 kyson kyson 20 11月 16 17:19 luci.targetindex -&gt; luci.tmp/.targetinfo drwxrwxr-x 3 kyson kyson 4096 11月 16 17:19 luci.tmp drwxrwxr-x 14 kyson kyson 4096 11月 16 17:19 management lrwxrwxrwx 1 kyson kyson 27 11月 16 17:19 management.index -&gt; management.tmp/.packageinfo lrwxrwxrwx 1 kyson kyson 26 11月 16 17:19 management.targetindex -&gt; management.tmp/.targetinfo drwxrwxr-x 3 kyson kyson 4096 11月 16 17:19 management.tmp drwxrwxr-x 14 kyson kyson 4096 11月 16 17:19 oldpackages lrwxrwxrwx 1 kyson kyson 28 11月 16 17:20 oldpackages.index -&gt; oldpackages.tmp/.packageinfo lrwxrwxrwx 1 kyson kyson 27 11月 16 17:20 oldpackages.targetindex -&gt; oldpackages.tmp/.targetinfo drwxrwxr-x 3 kyson kyson 4096 11月 16 17:20 oldpackages.tmp drwxrwxr-x 14 kyson kyson 4096 11月 16 17:19 packages lrwxrwxrwx 1 kyson kyson 25 11月 16 17:19 packages.index -&gt; packages.tmp/.packageinfo lrwxrwxrwx 1 kyson kyson 24 11月 16 17:19 packages.targetindex -&gt; packages.tmp/.targetinfo drwxrwxr-x 3 kyson kyson 4096 11月 16 17:19 packages.tmp drwxrwxr-x 36 kyson kyson 4096 11月 16 17:19 routing lrwxrwxrwx 1 kyson kyson 24 11月 16 17:19 routing.index -&gt; routing.tmp/.packageinfo lrwxrwxrwx 1 kyson kyson 23 11月 16 17:19 routing.targetindex -&gt; routing.tmp/.targetinfo drwxrwxr-x 3 kyson kyson 4096 11月 16 17:19 routing.tmp drwxrwxr-x 5 kyson kyson 4096 11月 16 17:19 shadowsocks lrwxrwxrwx 1 kyson kyson 28 11月 16 17:19 shadowsocks.index -&gt; shadowsocks.tmp/.packageinfo lrwxrwxrwx 1 kyson kyson 27 11月 16 17:19 shadowsocks.targetindex -&gt; shadowsocks.tmp/.targetinfo drwxrwxr-x 3 kyson kyson 4096 11月 16 17:19 shadowsocks.tmp drwxrwxr-x 5 kyson kyson 4096 11月 16 17:19 telephony lrwxrwxrwx 1 kyson kyson 26 11月 16 17:19 telephony.index -&gt; telephony.tmp/.packageinfo lrwxrwxrwx 1 kyson kyson 25 11月 16 17:19 telephony.targetindex -&gt; telephony.tmp/.targetinfo drwxrwxr-x 3 kyson kyson 4096 11月 16 17:19 telephony.tmp Feeds installinstall 函数代码段： sub install() { # 解析参数 # -a : Install all packages from all feeds or from the specified feed using the -p option. ==&gt; 安装所有软件包 # -p &lt;feedname&gt;: Prefer this feed when installing packages. ==&gt; 指定安装包 # -d &lt;y|m|n&gt;: Set default for newly installed packages. ==&gt; 使能安装软件包开关 # -f : Install will be forced even if the package exists in core OpenWrt (override) # 这个函数调用 metadata.pm 模块包，把 ./tmp/.packageinfo 和 ./tmp/.targetinfo 包信息转换成 hash 结构，获取所有已安装的软件包 get_installed(); # 缓存 foreach my $f (@feeds) { # fetch all feeds get_feed($f-&gt;[1]); # look up the preferred feed $opts{p} and $f-&gt;[1] eq $opts{p} and $feed = $f; } # 如果指定 -a，则进入这个逻辑，遍历所有软件包 if($opts{a}) { foreach my $f (@feeds) { # 没有指定 -p，或者 -p 指定的软件包名与存储在 @feeds 的软件包一致，进入这个逻辑，否则 next if (!defined($opts{p}) or $opts{p} eq $f-&gt;[1]) { printf "Installing all packages from feed %s.\n", $f-&gt;[1]; get_feed($f-&gt;[1]); # get_feed 函数会把遍历的软件包保存到缓存，$feed_package 保存的是 %pacakge hash结构，这里是遍历所有的软件包以及子包 foreach my $name (sort { lc($a) cmp lc($b) } keys %$feed_package) { my $p = $feed_package-&gt;{$name}; next if $p-&gt;{vdepends}; if( $p-&gt;{name} ) { # 安装软件包 install_package($feed, $p-&gt;{name}, exists($opts{f})) == 0 or $ret = 1; get_feed($f-&gt;[1]); } } } } } else { # 如果不指定 -a，进入这个逻辑，直接安装指定的软件包 while ($name = shift @ARGV) { install_package($feed, $name, exists($opts{f})) == 0 or $ret = 1; } } } get_installed 函数代码段： sub get_installed() { system("$mk -s prepare-tmpinfo OPENWRT_BUILD="); clear_packages(); parse_package_metadata("./tmp/.packageinfo"); %installed = %package; %installed_targets = get_targets("./tmp/.targetinfo"); } get_feed 函数代码段： sub get_feed() { # 存储包信息到缓存 if (!defined($feed_cache{$feed})) { my $file = "./feeds/$feed.index"; clear_packages(); -f $file or do { print "Ignoring feed '$feed' - index missing\n"; return; }; parse_package_metadata($file) or return; my %target = get_targets("./feeds/$feed.targetindex"); # 把信息结构存储到缓存 $feed_cache{$feed} = [ { %package }, { %srcpackage }, { %target } ]; } # 提取相应的信息 $feed_package = $feed_cache{$feed}-&gt;[0]; $feed_src = $feed_cache{$feed}-&gt;[1]; $feed_target = $feed_cache{$feed}-&gt;[2]; return $feed_cache{$feed}-&gt;[0]; } install_package 函数代码段： sub install_package() { my $this_feed_target = lookup_target($feed, $name); $feed = lookup_package($feed, $name); # switch to the metadata for the selected feed my $cur = get_feed($feed-&gt;[1]); # is_core_package 函数检查软件包是不是核心包，通过检查临时标志文件判别： tmp/info/.packageinfo-feeds_xxx_$package 这种标志除外的软件包视为核心包 # If it's a core package and we don't want to override, just return !$force and is_core_package($src) and return 0; # 判断是否满足覆盖条件 my $override = 1 if ($force and is_core_package($src) and !$installed{$name}-&gt;{feed}); # 已安装，并且不覆盖，就直接返回 # check previously installed packages $installed{$name} and !$override and return 0; $installed{$src} = 1; # 安装软件包，其实就是创建软链接到 package/feeds/xxx do_install_package($feed, $pkg) == 0 or do { warn "failed.\n"; return 1; }; # 安装依赖软件包 # install all dependencies referenced from the source package foreach my $vpkg (@{$feed_src-&gt;{$src}}) { foreach my $dep (@{$vpkg-&gt;{depends}}, @{$vpkg-&gt;{builddepends}}, @{$vpkg-&gt;{"builddepends/host"}}) { next if $dep =~ /@/; $dep =~ s/^\+//; $dep =~ s/^.+://; $dep =~ s/\/.+$//; next unless $dep; install_package($feed, $dep, 0) == 0 or $ret = 1; } } } do_install_package 函数代码段： sub do_install_package($$) { my $feed = shift; my $pkg = shift; my $path = $pkg-&gt;{makefile}; if($path) { $path =~ s/\/Makefile$//; -d &quot;./package/feeds&quot; or mkdir &quot;./package/feeds&quot;; -d &quot;./package/feeds/$feed-&gt;[1]&quot; or mkdir &quot;./package/feeds/$feed-&gt;[1]&quot;; system(&quot;ln -sf ../../../$path ./package/feeds/$feed-&gt;[1]/&quot;); } else { warn &quot;Package is not valid\n&quot;; return 1; } return 0; }]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Coding Style]]></title>
    <url>%2Fposts%2F515db561%2F</url>
    <content type="text"><![CDATA[Coding styleWhitespace 对齐使用4个空格，而不用 tab 制表符 每行最多79个字符 长条件表达式分多行时，需要在原来缩进的基础上增加一层缩进，参考例1 在一文件里，function 和 class 之间空两行隔开 在 class 里，成员方法间空一行隔开 不能使用隐式分行的，需要使用反斜杠连接符，分行同样遵循条件表示式的分行缩进风格，参考例2 对于赋值操作，操作符前后仅有一个空格，参考例3 函数调用、列表索引以及关键字参数与括号不带空格 For example 1: if (expression_1, expression_2, expression_3, expression_4): do_something() For example 2: with open('/path/to/some/file/you/want/to/read') as file_1, \ open('/path/to/some/file/being/written', 'w') as files_2: file_2.write(file_1.read()) For example 3: Yes: x = 1 y = 2 long_variable = 3 No: x = 1 y = 2 long_variable = 3 For example 4: Immediately before the open parenthesis that starts the argument list of a function call: Yes: spam(1) No: spam (1) Immediately before the open parenthesis that starts an indexing or slicing: Yes: dct['key'] = lst[index] No: dct ['key'] = lst [index] if (expression): do_something() Yes: ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] ham[lower:upper], ham[lower:upper:], ham[lower::step] ham[lower+offset : upper+offset] ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)] ham[lower + offset : upper + offset] No: ham[lower + offset:upper + offset] ham[1: 9], ham[1 :9], ham[1:9 :3] ham[lower : : upper] ham[ : upper] Naming 函数、变量和属性使用小写字母加下划线的命名风格，参考例5 protected 实例属性使用单下划线开头，参考例6 private 实例属性使用双下划线开头，参考例6 类和异常使用单词首字母大写的命名风格，参考例6 常量使用全部字母大写的风格 类的成员方法第一个参数是self For example 5: Format: lowercase_underscore def print_usage(): print("Usage: xxx") For example 6: class TestEmployee: _emp_count = 0 __salary = 10000 表达式和语句 检查长度，而不检查空值，因为使用 if not somelist 当 somelist 是空值时，返回值是 false，参考例7 避免单行 if for while 和 except，参考例8 import通常分行,并且位于文件的顶部，分成三组（标准库、相关的第三方库、本地库）排放，每组间空一行隔开，参考例9 For example 7: Yes: if len(somelist) == 0: do_something() No: if somelist == []: do_something() if not somelist: do_something() For example 8: Yes: if expression: do_something() No: if expression: do_something() For example 9: import os import sys from subprocess import Popen, PIPE]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - Setup WPA2-Enterprise AP]]></title>
    <url>%2Fposts%2Fb0b35cda%2F</url>
    <content type="text"><![CDATA[How to setup a FreeRadius Server on OpenWrtInstall Packages# opkg update # opkg install freeradius2 freeradius2-mod-always freeradius2-mod-attr-filter freeradius2-mod-attr-rewrite freeradius2-mod-chap freeradius2-mod-detail freeradius2-mod-eap freeradius2-mod-eap-gtc freeradius2-mod-eap-md5 freeradius2-mod-eap-mschapv2 freeradius2-mod-eap-peap freeradius2-mod-eap-tls freeradius2-mod-eap-ttls freeradius2-mod-exec freeradius2-mod-expiration freeradius2-mod-expr freeradius2-mod-files freeradius2-mod-ldap freeradius2-mod-logintime freeradius2-mod-mschap freeradius2-mod-pap # opkg install freeradius2-mod-passwd freeradius2-mod-preprocess freeradius2-mod-radutmp freeradius2-mod-realm freeradius2-mod-sql freeradius2-mod-sql-mysql freeradius2-mod-sql-pgsql freeradius2-mod-sql-sqlite freeradius2-mod-sqlcounter freeradius2-mod-sqllog freeradius2-utils freeradius2-democerts Note that if there are any errors like this:Collected errors:* opkg_install_cmd: Cannot install package freeradius2-democerts . We should try again. Issue opkg install freeradius2-democerts command. Change Configuration FileAdd a New UserModify /etc/freeradius2/users, append one line might be: kyson Cleartext-Password := &quot;helloworld1&quot; Note that “kyson” is username, and “helloworld1” is password for wireless client. Define RADIUS ClientModify /etc/freeradius2/clients.conf, change those items on the section: client localhost { ipaddr = 192.168.8.1 secret = helloworld } RADIUS Server Configuration FileModify /etc/freeradius2/radiusd.conf, change those items on flowing sections: listen { type = auth # interface = br-lan } log { auth = yes } Generate New Certificates and Key With Openssl# opkg install openssl-util # cd /etc/freeradius2/certs &amp;&amp; rm *.pem # openssl genrsa -des3 –out ca.key 2048 # openssl req -new –x509 –days 9999 –key ca.key –out ca.pem # openssl genrsa –des3 –out server.key 2048 # openssl req –new –key server.key –out key.csr # openssl x509 –req –days 9999 –in server.csr –CA ca.pem –Cakey ca.key –set_serial 01 –out server.pem Configuration EAPModify /etc/freeradius2/eap.conf, change those items on the section: eap { tls { # This password is CA key password private_key_password = goodlife private_key_file = ${certdir}/server.key } } Change Wireless Configuration File to Support WPA2Modify /etc/config/wireless, one example might be: config wifi-iface option device &apos;radio0&apos; option network &apos;lan&apos; option mode &apos;ap&apos; option ssid &apos;GL-AR150-0fd&apos; option wds &apos;1&apos; option ifname &apos;wlan0&apos; option encryption &apos;wpa2&apos; # This password is consistent with /etc/freeradius2/clients.conf option auth_secret &apos;helloworld&apos; option auth_server &apos;192.168.8.1&apos; option auth_port &apos;1812&apos; Note that we should reboot the device when finishing the above step. As you see, successful in setting up WPA2-Enterprise security for router. Connect to WPA2-Enterprise APOn Windows7, my settings are as follows: Connecting to the AP which ssid is GL-AR150-0fd, and typing username and password. It works well. Seeing the radius log on router. # cat /var/log/radius.log Mon Sep 25 15:34:35 2017 : Info: Loaded virtual server Mon Sep 25 15:34:35 2017 : Info: Ready to process requests.Mon Sep 25 15:39:29 2017 : Auth: Login OK: [kyson] (from client localhost port 1 cli F0-D5-BF-7F-F6-4D via TLS tunnel)Mon Sep 25 15:39:29 2017 : Auth: Login OK: [kyson] (from client localhost port 1 cli F0-D5-BF-7F-F6-4D)]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Syncing Fork Repo]]></title>
    <url>%2Fposts%2F5255e100%2F</url>
    <content type="text"><![CDATA[How To Sync Fork RepoOverview在使用 github 过程，遇到过这么一个问题：当我 Fork 一个工程到自己的 Repo 进行开发，随着 original repository 不断的更新，我想把更新的内容同步到我的 Repo 怎么办？git fetch + git merge 能解决这个问题。 Checkout Fork Repo克隆我们 fork 过来的 repository 到本地主机： $ git clone https://github.com/YOUR_USERNAME/YOUR_FORK.git Configuring A Remote查看当前的 repository 的远程源： $ git remote -v 添加一个我们要同步的 repository，通常是 fork 过来的 repository 的出处： $ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 检查我们新添加的 remote repository： $ git remote -v origin https://github.com/domino-team/lede-1701.git (fetch) origin https://github.com/domino-team/lede-1701.git (push) upstream https://github.com/lede-project/source.git (fetch) upstream https://github.com/lede-project/source.git (push) Syncing A Fork拉取上游源的分支以及相应的 commits 到本地，这里我需要拉取 LEDE 的 lede-1701 分支的 commits： $ git fetch upstream 合并到 fork repository，以合并 LEDE 源的 lede-1701 分支为例： $ git merge upstream/lede-1701 注意：如果合并过程出现冲突，我们需要手动地解决合并冲突问题。 Generate a list of the files affected by the merge conflict. In this example, the file styleguide.md has a merge conflict. $ git status # On branch branch-b # You have unmerged paths. # (fix conflicts and run &quot;git commit&quot;) # # Unmerged paths: # (use &quot;git add ...&quot; to mark resolution) # # both modified: styleguide.md # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 在冲突文件我们可以找到诸如下面格式的内容： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD open an issue ======= ask your question in IRC. &gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 表示当前分支，&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a 表示要合并的分支，======= 表示分界线，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 和 ======= 之间的内容表示当前分支的内容，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a 之间的内容为要合并分支的内容。决定保留哪个分支的内容，删除另一分支的内容，并且删除冲突标识符 “&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD”、”=======” 和 “&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-a”。 完成同步以后，我们就可以把这些新内容 push 到 fork repository，这样就能实现 fork 过来的 repository 能跟 original repository 保持一致。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Language - Foundation]]></title>
    <url>%2Fposts%2F6fc7a62f%2F</url>
    <content type="text"><![CDATA[Basic Syntax分号C 程序中，分号表示语句的终止符。下面表示两条语句： printf("Hello World! \n"); return 0; 注释注释是 C 代码的帮助文本，被注释的代码不会被编译器编译。C 语言支持两种注释表示，分别是单行注释和多行注释。单行注释：以 “//“ 开头，到行尾的内容被注释；多行注释：以 “/*“ 开头，并以 “*/“ 结尾，中间的内容被注释。如： // This is single line comment /** * This is multiple lines comment */ 标识符标识符是指我们为变量variable、宏macro，函数function 等取的名字，它由字母（A-Z,a-z）、数字（0-9）、下划线”_”组成，并且首字符不能是数字，但可以是字母或者下划线。有效的标识符： abc _tmp a_123 关键字C 语言的保留字不能用作常亮、变量或任何标识符名称，关键字列表： auto else long switch break enum register typedef case extern return union char float short unsigned const for signed void continue goto sizeof volatile default if static while do int struct _Packed double Whitespace只有空格字符的行称为空行，C 编译器会忽略空行。C 程序中空格字符是描述空格(‘ ‘)、定位字符(‘ \t ‘)、CR(‘ \r ‘)、换行(‘ \n ‘)、垂直定位字符(‘ \v ‘)或翻页(‘ \f ‘)的术语。空格字符可以划分语句，如声明一整形变量： int age; 这里，int 与 age 之间必须有空格，编译器才能区分它们。另外，空格可以用于代码缩进以提高代码的可阅读性： fruit = apples + oranges; Data TypesInteger TypesFloating-Point TypesVoid TypeVariablesConstantsOperatorsDecision MakingLoopsFunctionArrayPointers未完，待续！！]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac80211 - Home]]></title>
    <url>%2Fposts%2F2047704a%2F</url>
    <content type="text"><![CDATA[OverviewTo be able to control wireless drivers from userspace, some IPC communication processes between kernel and userspace are used. At first ioctl with vendor dependent APIs was used. In 1996, Jean Tourrilhes creates wireless extensions (WE or WEXT). The Wireless Extension (WE) is a generic API allowing a driver to expose to the user space configuration and statistics specific to common Wireless LANs. In 2006, John Linville creates mac80211 and Johannes Berg creates cfg80211 and nl80211. Together it is intended to replace wireless extensions. +-------------+ | | | Userspace | | | +-------------+ ^ - - - | - - - - | nl80211 v +-------------+ | | | cfg80211 | | | +-------------+ +-------------+ | | | mac80211 | | driver | | | +-------------+ An important point is that nl80211/cfg80211/mac80211 no longer use ioctl, they use netlink. So, tools like iw, hostapd or the wpa_supplicant use some netlink libraries (like libnl or libnl-tiny) and the netlink interface public header which is of course nl80211.h. There is not so much documentations, but I advice you to read the libnl documentation and then the iw source code (because iw use libnl). Mac80211 Framework nl80211 is the interface between user space software (iw, wpa_supplicant, etc.) and the kernel (cfg80211 and mac80211 kernel modules, and specific drivers). The WiFi drivers and hardware could be Full-MAC or Soft-MAC (see Wireless_network_interface_controller). cfg80211_ops is a set of operations that Full-MAC drivers and mac80211 module register to cfg80211 module. ieee80211_ops is a set of operations that Soft-MAC drivers register to mac80211 module. ReferencesHow nl80211 library &amp; cfg80211 work?]]></content>
      <categories>
        <category>Mac80211</category>
      </categories>
      <tags>
        <tag>mac80211</tag>
        <tag>netlink</tag>
        <tag>nl80211</tag>
        <tag>cfg80211</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Language - Introduction]]></title>
    <url>%2Fposts%2F240e0bdb%2F</url>
    <content type="text"><![CDATA[OverviewC 是通用的高级语言，由 Dennis M. Ritchie 发明。UNIX 操作系统、C 编译器和基本上所有 UNIX 的应用程序都是用 C 语言实现的。C 语言现在已经成为一门被广泛使用的专业语言，其有以下一些特性： Easy to learn（易学） Strutured language（结构化语言） It produces effient programs（效率高） It can handle low-level activities（处理低层） It can be compiled on a variety of computer platforms（容易移植到不同平台） Environment Setup在开始编程之前，我们需要为 C 语言搭建运行环境，至少需要两个工具：(a) 文本编辑器；(b) C 编译器。 Text Editor编辑器用于编写程序，如 Notepad++、VIM、EMACS 或 Epsilon等，选择合适自己的编译器进行编码。用编辑器新建的文件称为源文件，源文件包含代码，C 程序的源码一般以 “.c” 为后缀。 The C CompileC 语言源码对人可读，但是机器只认识 0 和 1 的机器码，所以需要用编译器将源码“翻译”为机器码。经过编译的源码，最终生成可执行文件。最常用的编译器是 GNU C/C++ 编译器，下面介绍在不同操作系统安装 GNU C/C++ 编译器。 Installation on UNIX/Linux如果使用 UNIX 或者 Linux 操作系统，在命令行执行以下命令检查系统是否已经安装 GCC： $ gcc -v 如果安装了 GNU 编译器，则会在屏幕打印版本信息。如果没有安装，我们可以自己安装。详细安装教程访问：Installing GCC Installation on Mac OS如果使用 Mac OS X，可以从 Apple 官网下载 Xcode IDE，它包含了 GNU C/C++ 编译器。详细安装教程访问：Xcode Installation on Windows如果要在 Windows 安装 GNU C/C++ 编译器，我们需要安装 MinGW - MinGW homepage，下载最新版并且安装，成功安装 MinGW 后，运行 MinGW 安装 gcc-core, gcc-g++, binutils, 和 MinGW runtime。一切无误后，添加 MinGW 的 bin 子目录到 PATH 系统环境变量，安装成功后，我们可以在 dos 命令行使用这些工具（gcc, g++, ar, ranlib, …）。 Program StructureBefore we study the basic building blocks of the C programming language, let us look at a bare minimum C program structure so that we can take it as a reference in the upcoming chapters. Hello World Example Preprocessor Commands Functions Variables Statements &amp; Expressions Comments Let us look at a simple code that would print the words “Hello World”： #include &lt;stdio.h&gt; int main() { /* my first program in C */ printf("Hello, World! \n"); return 0; } Let us take a look at the various parts of the above program： The first line of the program #include is a preprocessor command, which tells a C compiler to include stdio.h file before going to actual compilation. The next line int main() is the main function where the program execution begins. The next line /…/ will be ignored by the compiler and it has been put to add additional comments in the program. So such lines are called comments in the program. The next line printf(…) is another function available in C which causes the message “Hello, World!” to be displayed on the screen. The next line return 0; terminates the main() function and returns the value 0. Compile and Execute C ProgramLet us see how to save the source code in a file, and how to compile and run it. Following are the simple steps： Open a text editor and add the above-mentioned code. Save the file as hello.c Open a command prompt and go to the directory where you have saved the file. Type gcc hello.c and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line and would generate a.out executable file. Now, type a.out to execute your program. You will see the output “Hello World” printed on the screen. $ gcc hello.c $ ./a.out Hello, World!]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - How Initd Process Work]]></title>
    <url>%2Fposts%2Ff502ce40%2F</url>
    <content type="text"><![CDATA[Overview我们都知道 linux kernel 启动完成以后，会启动 /sbin/initd 作为第一个用户空间的进程。同样地，OpenWrt 也遵循这个规则，不同的是 OpenWrt 的主服务器进程是 procd，而 procd 是系统启动过程由 initd 切换过来的。 Checkout source使用以下命令克隆 procd 源码到本地： # git clone git://git.openwrt.org/project/procd.git Initd processinitd 进程是在内核启动完成后启动的第一个用户空间进程，它的主程序是 init.c，主要做了以下的一些工作： mount filesystem, proc &amp; sysfs &amp; cgroup &amp; tmpfs &amp; devpts create essential temporary directory, /tmp/run &amp; /tmp/lock &amp; /tmp/state set PATH environment, PATH=”/usr/sbin:/sbin:/usr/bin:/bin” set debug level by finding key is “init_debug” from /proc/cmdline register timeout callback, which call watchdog fork one child process to execute “/sbin/kmodloader /etc/modules-boot.d/“, which will load kernel modules, and parent process continue process management: procd and preinit. For procd, fork a child process to run as hotplug daemon with command “/sbin/procd -h /etc/hotplug-preinit.json”, the parent process register plugd_proc to uloop_process. For preinit, fork a child process to execute “/bin/sh /etc/preinit”, and the parent process register preinit_proc to uloop_process run loop 注意：这里的第7点，用到了 uloop 的进程管理。对于调用者，只需要关心 struct uloop_process 的 pid 和 cb 成员，其中，cb 是回调，当子进程退出时，父进程会收到 SIGCHLD 信号而调用。通过 uloop_process_add 把 struct uloop_process 添加到 uloop 事件循环中。 Initd to Procd我们透过简化代码分析 initd 进程是如何切换到 procd 进程： /* global various */ static struct uloop_process preinit_proc; void preinit(void) { char *init[] = { "/bin/sh", "/etc/preinit", NULL }; preinit_proc.cb = spawn_procd; preinit_proc.pid = fork(); if (!preinit_proc.pid) { execvp(init[0], init); ERROR("Failed to start preinit\n"); exit(-1); } if (preinit_proc.pid &lt;= 0) { ERROR("Failed to start new preinit instance\n"); return; } uloop_process_add(&amp;preinit_proc); } 根据上面提到 uloop 的进程管理可知，一旦执行完 /bin/sh /etc/preinit，则会执行 spawn_procd 回调。spawn_procd 的代码段： static void spawn_procd(struct uloop_process *proc, int ret) { char *argv[] = { "/sbin/procd", NULL}; struct stat s; if (plugd_proc.pid &gt; 0) kill(plugd_proc.pid, SIGKILL); if (!stat("/tmp/sysupgrade", &amp;s)) while (true) sleep(1); execvp(argv[0], argv); } spawn_procd 作为 initd 进程中 uloop_run 的回调函数，其 pid = 1(initd)，通过执行 execvp 拉起一进程取代原进程，这里是 initd 进程被 /sbin/procd 进程取代。至此，procd 成为 OpenWrt 系统的主服务进程(pid = 1)。 Procd processTODO]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - How DHCP Client Work]]></title>
    <url>%2Fposts%2F4d5e1cf%2F</url>
    <content type="text"><![CDATA[PresentationOpenWrt 缺省控制 DHCP 的进程如下： udhcpc - DHCP IPV4 client odhcp6c - DHCP IPV6 client DNSmasq - DHCP IPV4 server odhcpd - DHCP IPV6 server 使用 ps 命令查看 udhcpc 运行参数情况： # ps -w | grep udhcpc udhcpc 运行的参数类似这样： 2339 root 1204 S udhcpc -p /var/run/udhcpc-eth0.2.pid -s /lib/netifd/dhcp.script -f -t 0 -i eth0.2 -x hostname GL-MT300N-V 2674 root 1204 S udhcpc -p /var/run/udhcpc-apcli0.pid -s /lib/netifd/dhcp.script -f -t 0 -i apcli0 -C -O 121 对于我的路由器，当前系统 apcli0 和 eth0.2 网络接口使用了 DHCP 协议，当有 DHCP 事件被触发，会执行 /lib/netifd/dhcp.script 脚本。 Udhcpc startup通过 grep 搜索，发现启动 udhcpc 的代码在 /lib/netifd/proto/dhcp.sh 脚本中，proto_dhcp_setup 函数代码段： proto_run_command "$config" udhcpc \ -p /var/run/udhcpc-$iface.pid \ -s /lib/netifd/dhcp.script \ -f -t 0 -i "$iface" \ ${ipaddr:+-r $ipaddr} \ ${hostname:+-x "hostname:$hostname"} \ ${vendorid:+-V "$vendorid"} \ $clientid $broadcast $release $dhcpopts 这里调用了 proto_run_command 函数，同样地，搜索到它是 /lib/netifd/netifd-proto.sh 提供的脚本 api，代码段： proto_run_command() { local interface="$1"; shift json_init json_add_int action 1 json_add_array command while [ $# -gt 0 ]; do json_add_string "" "$1" shift done json_close_array [ -n "$_EXPORT_VARS" ] &amp;&amp; { json_add_array env for var in $_EXPORT_VARS; do eval "json_add_string \"\" \"\${$var}\"" done json_close_array } _proto_notify "$interface" } proto_run_command 函数就是初始化了json object，往 json object 添加了 string 类型的 action 和 array 类型的 command 字段，把传进来的参数全部填充到 command array中，最后调用了_proto_notify。 _proto_notify 函数代码段： _proto_notify() { local interface="$1" local options="$2" json_add_string "interface" "$interface" ubus $options call network.interface notify_proto "$(json_dump)" } 由此可以看出，最终使用 ubus 把 json 格式的内容发送到 ubusd 处理，network.interface 对象的 notify_proto 方法。 我们可以通过命令行查看 network.interface 对象注册了哪些方法以及怎么使用： # ubus -v list network.interface notify_proto 方法在背后做了哪些工作呢？我们可以通过 netifd 源码来寻找答案。notify_proto 的定义在 ubus.c 文件中，netifd 源码： # git clone git://git.openwrt.org/project/netifd.git static struct ubus_method iface_object_methods[] = { { .name = "up", .handler = netifd_handle_up }, { .name = "down", .handler = netifd_handle_down }, { .name = "renew", .handler = netifd_handle_renew }, { .name = "status", .handler = netifd_handle_status }, { .name = "prepare", .handler = netifd_handle_iface_prepare }, { .name = "dump", .handler = netifd_handle_dump }, UBUS_METHOD("add_device", netifd_iface_handle_device, dev_link_policy ), UBUS_METHOD("remove_device", netifd_iface_handle_device, dev_link_policy ), { .name = "notify_proto", .handler = netifd_iface_notify_proto }, { .name = "remove", .handler = netifd_iface_remove }, { .name = "set_data", .handler = netifd_handle_set_data }, }; 通过跟踪代码，调用顺序大致是这样： netifd_iface_notify_proto --–&gt; iface-&gt;proto-&gt;notify ---&gt; 回调的注册： state-&gt;proto.notify = proto_shell_notify; ---&gt; proto_shell_run_command ---&gt; netifd_start_process ---&gt; 创建子进程调用execvp执行脚本命令 至此，我们可以知道，刚开始分析的 udhcpc 作为脚本 api proto_run_command 的传入参数，最终通过 ubus 通讯，由 netifd 执行 execvp 带起 udhcpc。 Example以重新获取 wan 口的 ip 地址为例演示上面的过程，/lib/netifd/proto/dhcp.sh 的 proto_dhcp_renew 函数可以重新租约 ip 地址，proto_dhcp_renew 函数代码段： proto_dhcp_renew() { local interface="$1" # SIGUSR1 forces udhcpc to renew its lease local sigusr1="$(kill -l SIGUSR1)" [ -n "$sigusr1" ] &amp;&amp; proto_kill_command "$interface" $sigusr1 } proto_dhcp_renew 函数需要接收一个 interface( wan | wan6 | lan | wwan | … ) 参数，重新租约 wan 口的 ip： proto_dhcp_renew "wan" 注意：这里只是为了演示过程，实际上不能直接调用的。 proto_dhcp_renew 调用了 proto_kill_command，代码段： _proto_notify() { local interface="$1" local options="$2" json_add_string "interface" "$interface" ubus $options call network.interface notify_proto "$(json_dump)" } proto_kill_command() { local interface="$1"; shift json_init json_add_int action 2 [ -n "$1" ] &amp;&amp; json_add_int signal "$1" _proto_notify "$interface" } 前面分析可知，这里是构造了一个 json 格式消息，然后通过调用 _proto_notify 把消息发送到 ubusd 处理，这里的 json_dump 内容为： { "interface": "wan", "action": 2, "signal": 16 } proto_dhcp_renew &quot;wan&quot; 其实等价于命令行执行： # ubus call network.interface notify_proto '{"action":2,"signal":16,"interface":"wan"}' Troubleshoot前面提到入口在 /lib/netifd/proto/dhcp.sh 脚本，我们分析一下这个脚本是怎样被执行的？ netifd 主程序是 main.c，netifd 在启动的时候，调用了 proto_shell_init 函数。proto_shell_init 的实现代码以及分析注释： void proto_shell_init(void) { /* 获取 /lib/netifd/proto 文件描述符 */ proto_fd = netifd_open_subdir("proto"); if (proto_fd &lt; 0) return; netifd_init_script_handlers(proto_fd, proto_shell_add_handler); } netifd_init_script_handlers 的实现代码： void netifd_init_script_handlers(int dir_fd, script_dump_cb cb) { glob_t g; int i, prev_fd; prev_fd = netifd_dir_push(dir_fd); if (glob("./*.sh", 0, NULL, &amp;g)) return; for (i = 0; i &lt; g.gl_pathc; i++) netifd_parse_script_handler(g.gl_pathv[i], cb); netifd_dir_pop(prev_fd); globfree(&amp;g); } netifd_parse_script_handler 函数执行 /lib/netifd/proto 目录下的所有.sh文件，dump 作为传入参数。对于dhcp.sh，在脚本执行： init_proto "dump" add_protocol dhcp 其中，init_proto 和 add_protocol 为 netifd-proto.sh 的函数接口。 add_protocol ---&gt; proto_dhcp_init_config 并且构造一个 json 格式消息作为返回，netifd 的 netifd_parse_script_handler 函数将执行 dhcp.sh 脚本的返回值封装成 json 对象。 netifd_init_script_handlers ---&gt; netifd_parse_script_handler ---&gt; netifd_init_script_handler --&gt; proto_shell_add_handler ---&gt; add_proto_handler ---&gt; avl_insert proto_shell_add_handler 是 netifd_init_script_handlers 注册的回调函数，在 netifd_init_script_handler 被调用。proto_shell_add_handler 函数把 json 解析到 struct proto_handler 对应的成员变量中，然后把它插入到 avl 树中。]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt - Build System]]></title>
    <url>%2Fposts%2F7fbfd015%2F</url>
    <content type="text"><![CDATA[About OpenWrtOpenWrt 是具有高扩展性适合嵌入式设备的 GNU/Linux 发行版，一般应用于无线路由器。OpenWrt build system 包含了 Makefile 及 patch，这一特性大大简化了软件包的移植，交叉编译工具链使用 musl 和 tiny C standard library。 Prerequisites在编译OpenWrt固件之前，需要在宿主主机安装相关的依赖软件包。以Ubuntu 64bit为例： sudo apt-get install build-essential subversion libncurses5-dev zlib1g-dev gawk gcc-multilib flex git-core gettext libssl-dev unzip 其他平台参考：OpenWrt build system – Installation Build firmwareCheckout source如果使用trunk版本，使用下面的命令： git clone https://www.github.com/openwrt/openwrt 如果使用发布版本，使用下面的命令： git clone https://www.github.com/openwrt/openwrt -b chaos_calmer 可以到OpenWrt-github查看当前发布版本！ Update feeds进入刚才用git下载的源码目录，更新OpenWrt的package feeds： cd openwrt ./scripts/feeds update ./scripts/feeds install -a update - 软件包的源位于 ./feeds.conf.default, 可以通过修改这个文件自定义更新软件包的路径。 install - 把 feeds 目录下所有的源创建软链接到 package/feeds 目录。 Make menuconfig选择编译平台： make menuconfig Target System ---&gt; Subtarget ---&gt; Target Profile ---&gt; Build imagemake V=s V=s - 打印编译详细信息。 如果想加快编译速度，对于多核CPU可以加 -j 参数，开启5个线程同时编译： make -j 5 V=s 还可以对输出做重定向处理，把所有输出信息重定向到文件，只打印错误信息： make V=s 2&gt;&amp;1 | tee build.log | grep -i error 注意： 编译过程花费很长的时间，因为 git clone 的只是 OpenWrt 框架，不包含任何软件包的源码，所需的软件包是在编译时下载的，并且存放在 $buildroot/dl 目录下，如果编译由于网络问题导致一些源码包无法下载，我们可以通过浏览器搜索相应的软件包，然后拷贝到 dl 目录，重新编译。 Locate image如果编译无误，最终镜像生成在 $buildroot_dir/bin/$target_platform 目录下。例如 buildroot 目录是 ~/openwrt/，编译的目标平台是ar71xx，则镜像位于： ~/openwrt/bin/ar71xx Clean upmake clean 删除 $buildroot/bin 和 $buildroot/build_dir 目录的内容，但是不会删除交叉编译工具链。 make dirclean 删除 $buildroot/bin、$buildroot/build_dir、$buildroot/staging_dir、 $buildroot/toolchain 和 $buildroot/logs。 make distclean 删除所有内容，包括 feeds 和 dl，还原到 git clone 的状态。]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
</search>
